<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>飞翔的企鹅</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这里是介绍">
<meta property="og:type" content="website">
<meta property="og:title" content="飞翔的企鹅">
<meta property="og:url" content="https://blog.okjvm.com/page/3/index.html">
<meta property="og:site_name" content="飞翔的企鹅">
<meta property="og:description" content="这里是介绍">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="飞翔的企鹅">
<meta name="twitter:description" content="这里是介绍">
  
    <link rel="alternate" href="/atom.xml" title="飞翔的企鹅" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.okjvm.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">飞翔的企鹅</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎访问</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java/iostream/ioStreamOther" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/20/java/iostream/ioStreamOther/" class="article-date">
  <time datetime="2018-11-20T06:26:28.000Z" itemprop="datePublished">2018-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/20/java/iostream/ioStreamOther/">IO流其他</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li>1.字符流出现的原因</li>
<li>2.String中的编解码问题</li>
<li>3.转换流<ul>
<li>3.1 转换流OutputStreamWriter的使用</li>
<li>3.2 转换流InputStreamReader的使用</li>
<li>3.3 字符流的5种写数据的方式</li>
<li>3.4 字符流的2种读数据的方式</li>
<li>3.5 高效流FileWriter和FileReader</li>
<li>3.6 字符缓冲流的基本使用</li>
<li>3.7 字符缓冲流的特殊功能</li>
</ul>
</li>
<li>4.IO流的练习题<ul>
<li>4.1 字符流复制文本文件</li>
<li>4.2 FileWriter和FileReader复制文本文件</li>
<li>4.3 字符缓冲流的特殊功能复制文本文件</li>
<li>4.4 把集合中的数据存储到文本文件</li>
<li>4.5 把文本文件中的数据存储到集合中</li>
<li>4.6 随机获取文本文件中的姓名</li>
<li>4.7 复制单级文件夹</li>
<li>4.8 复制指定目录下指定后缀名的文件并修改名称</li>
<li>4.7和4.8工具类</li>
<li>4.9 键盘录入学生信息按照总分排序并写入文本文件</li>
</ul>
</li>
<li>5.IO流大总结<ul>
<li>5.1 按操作方式分类结构图</li>
<li>5.2 按操作对象分类结构图</li>
</ul>
</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/20/java/iostream/ioStreamOther/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/20/java/iostream/ioStreamOther/" data-id="ckkrzb8yj003hcv2afv2zhroe" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io/">io</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/iostream/ioStreamBase" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/20/java/iostream/ioStreamBase/" class="article-date">
  <time datetime="2018-11-20T02:59:58.000Z" itemprop="datePublished">2018-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/20/java/iostream/ioStreamBase/">IO流基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li>1.IO的概述<ul>
<li>1.1 IO流概述及其前奏</li>
</ul>
</li>
<li>2.IO流整体介绍</li>
<li>3.File文件类<ul>
<li>3.1 File类的概述和方法介绍【掌握】</li>
</ul>
</li>
<li>4.递归<ul>
<li>4.1 递归概述和注意事项</li>
</ul>
</li>
<li>5.IO流<ul>
<li>5.1 IO流概述及其分类【掌握】</li>
<li>5.2 输入流和输出流分类</li>
<li>5.3 IO流基类概述和FileOutputStream的构造方法【掌握】</li>
<li>5.4 FileOutputStream【掌握】</li>
<li>5.5 FileInputStream【掌握】</li>
</ul>
</li>
<li>6.IO流案例<ul>
<li>6.1 字节流复制文本文件【字节流一次读写一个字节复制文本文件】</li>
<li>6.2 字节流复制MP3【字节流一次读写一个字节复制MP3】</li>
<li>6.3 FileInputStream读取数据一次一个字节数组</li>
<li>6.4 FileInputStream读取数据的两种方式比较</li>
<li>6.5 字节流复制文本文件【字节流一次读写一个字节数组复制文本文件】</li>
<li>6.6 字节流复制MP3【字节流一次读写一个字节数组复制MP3】</li>
</ul>
</li>
<li>7.Buffer缓冲数据流<ul>
<li>7.1 BufferedOutputStream写出数据</li>
<li>7.2 BufferedInputStream读取数据</li>
<li>7.3 字节流四种方式复制MP3并测试效率<ul>
<li>基本字节流一次读写一个字节</li>
<li>基本字节流一次读写一个字节数组</li>
<li>高效字节流一次读写一个字节</li>
<li>高效字节流一次读写一个字节数组</li>
</ul>
</li>
<li>7.4 总结</li>
</ul>
</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/20/java/iostream/ioStreamBase/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/20/java/iostream/ioStreamBase/" data-id="ckkrzb8yi003fcv2ami60sd02" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/io/">io</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/thread/07-threadDeadLock" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/16/java/thread/07-threadDeadLock/" class="article-date">
  <time datetime="2018-11-16T09:55:00.000Z" itemprop="datePublished">2018-11-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/16/java/thread/07-threadDeadLock/">线程死锁</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.代码模拟产生死锁<ul>
<li>1.1 代码描述</li>
<li>1.2 产生死锁代码</li>
<li>1.3 死锁发生的场景</li>
</ul>
</li>
<li>2.Java中导致死锁的原因<ul>
<li>2.1 造成死锁原因</li>
<li>2.2 死锁的危害</li>
</ul>
</li>
<li>3.出现死锁需要满足条件<ul>
<li>3.1 死锁问题条件</li>
<li>3.2 如何预防死锁</li>
</ul>
</li>
<li>4.死锁诊断步骤<ul>
<li>4.1 如何定位死锁</li>
</ul>
</li>
<li>5.死锁修复解决方案<ul>
<li>5.1 死锁修复方案</li>
</ul>
</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/16/java/thread/07-threadDeadLock/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/16/java/thread/07-threadDeadLock/" data-id="ckkrzb8ya0037cv2a00soj9w7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/thread/06-closeThread" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/java/thread/06-closeThread/" class="article-date">
  <time datetime="2018-11-15T09:54:59.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/java/thread/06-closeThread/">Thread关闭方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.Thread线程</li>
<li>2.结束Thread线程的几种方法</li>
<li>3.使用退出标志终止线程</li>
<li>4.使用interrupt()方法终止线程</li>
<li>5.使用stop方法终止线程</li>
<li>6.关于Thread源码分析</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/15/java/thread/06-closeThread/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/15/java/thread/06-closeThread/" data-id="ckkrzb8xp002ccv2abums84c9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/thread/05-synchronizeAndReentrantLock" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/14/java/thread/05-synchronizeAndReentrantLock/" class="article-date">
  <time datetime="2018-11-14T09:54:58.000Z" itemprop="datePublished">2018-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/14/java/thread/05-synchronizeAndReentrantLock/">synchronize与ReentrantLock</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.Synchronize和ReentrantLock区别<ul>
<li>1.1 相似点</li>
<li>1.2 区别</li>
<li>1.3 什么是线程安全问题？如何理解</li>
<li>1.4 线程安全需要保证几个基本特性</li>
</ul>
</li>
<li>2.Synchronize在编译时如何实现锁机制</li>
<li>3.ReentrantLock使用方法</li>
<li>4.ReentrantLock锁机制测试案例分析<ul>
<li>4.1 代码案例分析</li>
<li>4.2 什么时候选择用ReentrantLock</li>
<li>4.3 公平锁和非公平锁有何区别</li>
</ul>
</li>
<li>5.问答测试题<ul>
<li>5.1 ReentrantLock和synchronized使用分析</li>
</ul>
</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/14/java/thread/05-synchronizeAndReentrantLock/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/14/java/thread/05-synchronizeAndReentrantLock/" data-id="ckkrzb8y90035cv2ax7ka0hjc" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/thread/04-synchronize" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/11/java/thread/04-synchronize/" class="article-date">
  <time datetime="2018-11-11T09:54:57.000Z" itemprop="datePublished">2018-11-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/11/java/thread/04-synchronize/">synchronize深入理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.synchronized简单介绍<ul>
<li>1.1 简单介绍</li>
<li>1.2 可以修饰哪些内容</li>
</ul>
</li>
<li>2.synchonized(this)和synchonized(object)区别</li>
<li>3.sychonized method 和 synchonized代码块的效率问题</li>
<li>4.代码使用案例<ul>
<li>4.1 第一个案例代码</li>
<li>4.2 第二个案例代码【 同步代码块时】</li>
<li>4.3 第三个案例代码【 synchronized对象锁 】</li>
</ul>
</li>
<li>5.结论</li>
<li>6.Synchronize问题<ul>
<li>6.1 Synchronize作用于方法和静态方法区别</li>
</ul>
</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/11/java/thread/04-synchronize/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/11/java/thread/04-synchronize/" data-id="ckkrzb8y80033cv2ak4z5wwu7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/08-classLoader" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/09/java/base/08-classLoader/" class="article-date">
  <time datetime="2018-11-09T07:57:29.000Z" itemprop="datePublished">2018-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/09/java/base/08-classLoader/">类加载机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>01.Java对象的创建过程<ul>
<li>1.0 看下创建类加载过程</li>
<li>1.1 对象的创建</li>
<li>1.2 对象的内存布局</li>
</ul>
</li>
<li>02.Java内存区域<ul>
<li>2.0 运行时数据区域</li>
<li>2.1 程序计数器</li>
<li>2.2 虚拟机栈</li>
<li>2.3 本地方法栈</li>
<li>2.4 Java堆</li>
<li>2.5 方法区</li>
<li>2.6 运行时常量池</li>
<li>2.7 直接内存</li>
</ul>
</li>
<li>03.Java对象的访问定位方式<ul>
<li>3.1 句柄</li>
<li>3.2 直接指针</li>
</ul>
</li>
<li>04.Java对象销毁分析<ul>
<li>4.1 JVM内存分配与回收</li>
<li>4.2 判断对象是否死亡</li>
<li>4.3 不可达的对象并非“非死不可”</li>
<li>4.4 如何判断一个常量是废弃常量</li>
<li>4.5 如何判断一个类是无用的类</li>
<li>4.6 GC回收算法详解</li>
</ul>
</li>
<li>05.String类和常量池<ul>
<li>5.1 String对象的两种创建方式</li>
<li>5.2 String类型的常量池</li>
</ul>
</li>
</ul>
<h3 id="问题思考答疑"><a href="#问题思考答疑" class="headerlink" title="问题思考答疑"></a>问题思考答疑</h3><ul>
<li>说一下创建一个对象，类的加载过程。类信息，常量，变量，方法分别放到内存中哪里？</li>
<li>对于运行时数据区域，哪些是私有的，哪些是共享的，为什么要这样设计？</li>
<li>程序计数器会出现OOM吗？它的生命周期是怎么样的？</li>
<li>本地方法栈和Java虚拟机栈有什么区别？本地方法栈在什么情况下会造成OOM？</li>
<li>java堆主要是做什么作用的？</li>
<li>什么是类的加载检查，主要检查什么，如何检查呢？</li>
<li>Java对象访问定位方式有哪些？主要有什么区别？为什么说使用指针效率更高？</li>
<li>String类可以new吗？直接new和赋值的内容有什么区别，分别放在内存中什么地方？</li>
<li>如何判断对象是否死亡（两种方法）。如果有不同方法，那么之间有什么区别？</li>
<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>
<li>如何判断一个常量是废弃常量，如何判断一个类是无用的类？</li>
<li>垃圾收集有哪些算法，各自的特点？常见的垃圾回收器有那些？</li>
<li>HotSpot为什么要分为新生代和老年代？</li>
<li>介绍一下CMS,G1收集器。Minor Gc和Full GC 有什么不同呢？</li>
</ul>
<h3 id="01-Java对象的创建过程"><a href="#01-Java对象的创建过程" class="headerlink" title="01.Java对象的创建过程"></a>01.Java对象的创建过程</h3><h4 id="1-1-看下创建类加载过程"><a href="#1-1-看下创建类加载过程" class="headerlink" title="1.1 看下创建类加载过程"></a>1.1 看下创建类加载过程</h4><ul>
<li>Person p = new Person()请写一下类的加载过程？  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1).因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;</span><br><span class="line">2).执行该类中的static代码块，如果有的话，给Person.class类进行初始化;</span><br><span class="line">3).在堆内存中开辟空间分配内存地址;</span><br><span class="line">4).在堆内存中建立对象的特有属性，并进行默认初始化;</span><br><span class="line">5).对属性进行显示初始化;</span><br><span class="line">6).对对象进行构造代码块初始化;</span><br><span class="line">7).对对象进行与之对应的构造函数进行初始化;</span><br><span class="line">8).将内存地址付给栈内存中的p变量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h4><ul>
<li>Java对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。<ul>
<li>1.类加载检查</li>
<li>2.分配内存</li>
<li>3.初始化零值</li>
<li>4.设置对象头</li>
<li>5.执行init方法</li>
</ul>
</li>
<li><strong>①类加载检查：</strong> <ul>
<li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
</ul>
</li>
<li><strong>②分配内存：</strong> <ul>
<li>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</li>
<li><strong>内存分配的两种方式：</strong><ul>
<li>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（”标记-压缩”），值得注意的是，复制算法内存也是规整的</li>
</ul>
</li>
<li><strong>内存分配并发问题</strong><ul>
<li>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</li>
</ul>
</li>
<li><strong>CAS+失败重试：</strong><ul>
<li>CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
</ul>
</li>
<li><strong>TLAB：</strong><ul>
<li>为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配</li>
</ul>
</li>
</ul>
</li>
<li><strong>③初始化零值：</strong> <ul>
<li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
</ul>
</li>
<li><strong>④设置对象头：</strong>   <ul>
<li>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。</li>
<li><strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
</ul>
</li>
<li><strong>⑤执行 init 方法：</strong><ul>
<li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li>
</ul>
</li>
</ul>
<h4 id="1-2-对象的内存布局"><a href="#1-2-对象的内存布局" class="headerlink" title="1.2 对象的内存布局"></a>1.2 对象的内存布局</h4><ul>
<li>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3快区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</li>
<li><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希吗、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</li>
<li><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</li>
<li><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></li>
<li>因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ul>
<h3 id="02-Java内存区域"><a href="#02-Java内存区域" class="headerlink" title="02.Java内存区域"></a>02.Java内存区域</h3><h4 id="2-0-运行时数据区域"><a href="#2-0-运行时数据区域" class="headerlink" title="2.0 运行时数据区域"></a>2.0 运行时数据区域</h4><ul>
<li>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</li>
<li>这些组成部分一些事线程私有的，其他的则是线程共享的。<ul>
<li><strong>线程私有的：</strong><ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
</li>
<li><strong>线程共享的：</strong><ul>
<li>Java堆</li>
<li>方法区</li>
<li>运行时常量池</li>
<li>直接内存</li>
</ul>
</li>
</ul>
</li>
<li><img src="/images/68747470733a2f2f75706c6.png" alt=""></li>
</ul>
<h4 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h4><ul>
<li>程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。</li>
<li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></li>
<li>程序计数器主要有两个作用：<ul>
<li>1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿。</li>
</ul>
</li>
<li><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></li>
</ul>
<h4 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h4><ul>
<li>Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。</li>
<li><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong>（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</li>
<li><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li>
<li><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong><ul>
<li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li>
<li><strong>OutOfMemoryError：</strong> 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li>
</ul>
</li>
<li>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</li>
</ul>
<h4 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h4><ul>
<li>本地方法栈：跟虚拟机栈很像， <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
<li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li>
<li>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</li>
</ul>
<h4 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h4><ul>
<li>Java堆：所有线程共享的一块内存区域，此内存区域的唯一目的就是存放对象实例，对象实例几乎都在这分配内存。在虚拟机启动时创建。</li>
<li>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：在细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong><ul>
<li><img src="/images/68747470733a2f2f75706c67.png" alt=""></li>
</ul>
</li>
<li><strong>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</strong></li>
</ul>
<h4 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h4><ul>
<li>方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。<ul>
<li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
</ul>
</li>
<li><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong>如何理解这句话？</li>
</ul>
<h4 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h4><ul>
<li>运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。<ul>
<li>。Class 文件中包括类的版本、字段、方法、接口等描述信息 </li>
</ul>
</li>
<li>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。<strong>JDK1.7及之后版本的 JVM已经将运行时常量池从方法区中移了出来，在Java堆（Heap）中开辟了一块区域存放运行时常量池。</strong> </li>
</ul>
<h4 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h4><ul>
<li>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</li>
<li>JDK1.4中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</li>
<li>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</li>
</ul>
<h3 id="03-Java对象的访问定位方式"><a href="#03-Java对象的访问定位方式" class="headerlink" title="03.Java对象的访问定位方式"></a>03.Java对象的访问定位方式</h3><ul>
<li>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定</li>
<li>目前主流的访问方式有<ul>
<li><strong>①使用句柄</strong></li>
<li><strong>②直接指针</strong></li>
</ul>
</li>
<li><strong>这两种对象访问方式各有优势。</strong><ul>
<li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</li>
</ul>
</li>
</ul>
<h4 id="3-1-句柄"><a href="#3-1-句柄" class="headerlink" title="3.1 句柄"></a>3.1 句柄</h4><ul>
<li>如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；<br><img src="/images/6d616765732e6a69.png" alt=""></li>
</ul>
<h4 id="3-2-直接指针"><a href="#3-2-直接指针" class="headerlink" title="3.2 直接指针"></a>3.2 直接指针</h4><ul>
<li>如果使用直接指针访问，那么 Java 堆对像的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。<br><img src="/images/2d696d616765732e6a69616e.png" alt=""></li>
</ul>
<h3 id="04-Java对象销毁分析"><a href="#04-Java对象销毁分析" class="headerlink" title="04.Java对象销毁分析"></a>04.Java对象销毁分析</h3><ul>
<li><img src="/images/61642d696d616765732e6a69616e7.png" alt=""></li>
</ul>
<h4 id="4-1-JVM内存分配与回收"><a href="#4-1-JVM内存分配与回收" class="headerlink" title="4.1 JVM内存分配与回收"></a>4.1 JVM内存分配与回收</h4><ul>
<li>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</li>
<li><strong>JDK1.8之前的堆内存示意图：</strong><ul>
<li><img src="/images/68747470733a2f2f75706c67.png" alt=""></li>
<li>从上图可以看出堆内存的分为新生代、老年代和永久代。新生代又被进一步分为：Eden 区＋Survior1 区＋Survior2 区。值得注意的是，在JDK1.8中移除整个<code>永久代</code>，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</li>
</ul>
</li>
<li>分代回收算法<ul>
<li>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li>
<li>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</li>
</ul>
</li>
<li><strong>Minor Gc和Full GC 有什么不同呢？</strong><ul>
<li><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>老年代GC（Major GC/Full GC）</strong>:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
</li>
</ul>
<h4 id="4-2-判断对象是否死亡"><a href="#4-2-判断对象是否死亡" class="headerlink" title="4.2 判断对象是否死亡"></a>4.2 判断对象是否死亡</h4><ul>
<li>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。<ul>
<li><img src="/images/261326435306262353963.png" alt=""></li>
</ul>
</li>
</ul>
<h5 id="4-2-1-引用计数法"><a href="#4-2-1-引用计数法" class="headerlink" title="4.2.1 引用计数法"></a>4.2.1 引用计数法</h5><ul>
<li>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。<ul>
<li><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></li>
<li>所谓对象之间的相互引用问题，如下面代码所示：除了对象objA和objB相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Object instance = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Test objA = <span class="keyword">new</span> Test();</span><br><span class="line">		Test objB = <span class="keyword">new</span> Test();</span><br><span class="line">		objA.instance = objB;</span><br><span class="line">		objB.instance = objA;</span><br><span class="line">		objA = <span class="keyword">null</span>;</span><br><span class="line">		objB = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="4-2-2-可达性分析算法"><a href="#4-2-2-可达性分析算法" class="headerlink" title="4.2.2 可达性分析算法"></a>4.2.2 可达性分析算法</h5><ul>
<li>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。<ul>
<li><img src="/images/9616e7368752e696f2f75706c6f6.png" alt=""></li>
<li>通常的面试过程中回问到这块的知识。</li>
</ul>
</li>
</ul>
<h5 id="4-2-3-再谈引用"><a href="#4-2-3-再谈引用" class="headerlink" title="4.2.3 再谈引用"></a>4.2.3 再谈引用</h5><ul>
<li>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</li>
<li>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</li>
<li>关于四种引用以及源代码分析，可以看我的这篇文章：<a href="https://blog.csdn.net/m0_37700275/article/details/79820814" target="_blank" rel="noopener">https://blog.csdn.net/m0_37700275/article/details/79820814</a></li>
</ul>
<h4 id="4-3-不可达的对象并非“非死不可”"><a href="#4-3-不可达的对象并非“非死不可”" class="headerlink" title="4.3 不可达的对象并非“非死不可”"></a>4.3 不可达的对象并非“非死不可”</h4><ul>
<li>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</li>
<li>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</li>
</ul>
<h4 id="4-4-如何判断一个类是无用的类"><a href="#4-4-如何判断一个类是无用的类" class="headerlink" title="4.4 如何判断一个类是无用的类"></a>4.4 如何判断一个类是无用的类</h4><ul>
<li>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</li>
</ul>
<h4 id="4-5-GC回收算法详解"><a href="#4-5-GC回收算法详解" class="headerlink" title="4.5 GC回收算法详解"></a>4.5 GC回收算法详解</h4><ul>
<li>这个可以看我的另外一篇文章：<img src="http://www.baidu.com" alt="暂未开始写"></li>
</ul>
<h3 id="05-String类和常量池"><a href="#05-String类和常量池" class="headerlink" title="05.String类和常量池"></a>05.String类和常量池</h3><h4 id="5-1-String对象的两种创建方式"><a href="#5-1-String对象的两种创建方式" class="headerlink" title="5.1 String对象的两种创建方式"></a>5.1 String对象的两种创建方式</h4><ul>
<li><p><strong>1 String 对象的两种创建方式：</strong></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line">System.out.println(str1==str2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>这两种不同的创建方法是有差别的【记住：只要使用new方法，便需要创建新的对象】</p>
<ul>
<li>第一种方式是在常量池中拿对象</li>
<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>
</ul>
</li>
<li><img src="/images/75706c6f61642d.png" alt=""></li>
</ul>
<h4 id="5-2-String类型的常量池"><a href="#5-2-String类型的常量池" class="headerlink" title="5.2 String类型的常量池"></a>5.2 String类型的常量池</h4><ul>
<li><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong><ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"yc"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"yc"</span>;</span><br><span class="line"><span class="comment">//yc</span></span><br><span class="line">System.out.println(s2);</span><br><span class="line"><span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"><span class="comment">//true，因为两个都是常量池中的String对</span></span><br><span class="line">System.out.println(s3 == s2);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/09/java/base/08-classLoader/" data-id="ckkrzb8yf003acv2ackfaqzi7" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/thread/03-threadBackage" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/08/java/thread/03-threadBackage/" class="article-date">
  <time datetime="2018-11-08T09:54:56.000Z" itemprop="datePublished">2018-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/08/java/thread/03-threadBackage/">多线程深入理解2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li><strong>1.遇到的问题和需求</strong></li>
<li>1.1 遇到的问题有哪些</li>
<li>1.2 遇到的需求</li>
<li>1.3 多线程通过实现Runnable弊端</li>
<li>1.4 为什么要用线程池</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/08/java/thread/03-threadBackage/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/08/java/thread/03-threadBackage/" data-id="ckkrzb8xo002bcv2a6ml3emaa" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/07-javaBaseTypeCache" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/08/java/base/07-javaBaseTypeCache/" class="article-date">
  <time datetime="2018-11-08T08:14:10.000Z" itemprop="datePublished">2018-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/08/java/base/07-javaBaseTypeCache/">07 基础类型缓存池概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>01.以Integer为例</li>
</ul>
<h3 id="01-以Integer为例"><a href="#01-以Integer为例" class="headerlink" title="01.以Integer为例"></a>01.以Integer为例</h3><ul>
<li><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个Integer实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
</li>
<li>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/08/java/base/07-javaBaseTypeCache/" data-id="ckkrzb8xi001ycv2at12nq1xa" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/06-javaInteger" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/07/java/base/06-javaInteger/" class="article-date">
  <time datetime="2018-11-07T08:13:10.000Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/07/java/base/06-javaInteger/">06 int和Integer深入分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.关于int和Integer的问题区别分析</li>
<li>2.Integer的值缓存的原理<ul>
<li>2.1 Java 5 中引入缓存特性</li>
<li>2.2 Integer类中的IntegerCache类</li>
<li>2.3 其他整型类型的缓存机制</li>
</ul>
</li>
<li>3.理解自动装箱和拆箱<ul>
<li>3.1 什么是装箱？什么是拆箱？</li>
<li>3.2 装箱和拆箱是如何实现的</li>
<li>3.3 装箱和拆箱在编程实际中注意点</li>
</ul>
</li>
<li>4.原始类型线程安全问题<ul>
<li>4.1 那些类型是线程安全的</li>
<li>4.2 如何验证int类型是否线程安全</li>
<li>4.3 AtomicInteger线程安全版</li>
</ul>
</li>
<li>5.Java 原始数据类型和引用类型局限性<ul>
<li>5.1 原始数据类型和 Java 泛型并不能配合使用</li>
<li>5.2 无法高效地表达数据，也不便于表达复杂的数据结构</li>
</ul>
</li>
<li>6.关于其他知识延伸<ul>
<li>6.1 对象的内存结构</li>
<li>6.2 对象头的结构</li>
<li>6.3 如何计算或者获取某个Java对象的大小</li>
</ul>
</li>
<li>7.关于其他内容介绍<ul>
<li>7.1 关于博客汇总链接</li>
<li>7.2 关于我的博客</li>
</ul>
</li>
</ul>
<h3 id="1-关于int和Integer的问题区别分析"><a href="#1-关于int和Integer的问题区别分析" class="headerlink" title="1.关于int和Integer的问题区别分析"></a>1.关于int和Integer的问题区别分析</h3><ul>
<li>1.1 编译阶段、运行时，自动装箱 / 自动拆箱是发生在什么阶段？</li>
<li>1.2使用静态工厂方法 valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？</li>
<li>1.3为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？</li>
<li>1.4 阅读过 Integer 源码吗？分析下类或某些方法的设计要点？</li>
<li>1.5 int和Integer的区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1、Integer是int的包装类，int则是java的一种基本数据类型 </span><br><span class="line">2、Integer变量必须实例化后才能使用，而int变量不需要 </span><br><span class="line">3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </span><br><span class="line">4、Integer的默认值是null，int的默认值是0</span><br><span class="line"></span><br><span class="line">延伸： </span><br><span class="line">关于Integer和int的比较 </span><br><span class="line">1、由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。</span><br><span class="line"></span><br><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = new Integer(100);</span><br><span class="line">System.out.print(i == j); //false</span><br><span class="line"></span><br><span class="line">2、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</span><br><span class="line"></span><br><span class="line">Integer i = new Integer(100);</span><br><span class="line">int j = 100；</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br><span class="line">3、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）</span><br><span class="line"></span><br><span class="line">Integer i = new Integer(100);</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //false</span><br><span class="line"></span><br><span class="line">4、对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</span><br><span class="line"></span><br><span class="line">Integer i = 100;</span><br><span class="line">Integer j = 100;</span><br><span class="line">System.out.print(i == j); //true</span><br><span class="line"></span><br><span class="line">Integer i = 128;</span><br><span class="line">Integer j = 128;</span><br><span class="line">System.out.print(i == j); //false</span><br><span class="line"></span><br><span class="line">对于第4条的原因： </span><br><span class="line">java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</span><br><span class="line"></span><br><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-Integer的值缓存的原理"><a href="#2-Integer的值缓存的原理" class="headerlink" title="2.Integer的值缓存的原理"></a>2.Integer的值缓存的原理</h3><h4 id="2-1-Java-5-中引入缓存特性"><a href="#2-1-Java-5-中引入缓存特性" class="headerlink" title="2.1 Java 5 中引入缓存特性"></a>2.1 Java 5 中引入缓存特性</h4><ul>
<li>在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。</li>
<li>这种 Integer 缓存策略仅在自动装箱（autoboxing）的时候有用，使用构造器创建的 Integer 对象不能被缓存。</li>
</ul>
<h4 id="2-2-Integer类中的IntegerCache类"><a href="#2-2-Integer类中的IntegerCache类" class="headerlink" title="2.2 Integer类中的IntegerCache类"></a>2.2 Integer类中的IntegerCache类</h4><ul>
<li>在创建新的 Integer 对象之前会先在 IntegerCache.cache (是个Integer类型的数组)中查找。有一个专门的 Java 类来负责 Integer 的缓存。</li>
<li>这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-其他整型类型的缓存机制"><a href="#2-3-其他整型类型的缓存机制" class="headerlink" title="2.3 其他整型类型的缓存机制"></a>2.3 其他整型类型的缓存机制</h4><ul>
<li>这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。<ul>
<li>有 ByteCache 用于缓存 Byte 对象</li>
<li>有 ShortCache 用于缓存 Short 对象</li>
<li>有 LongCache 用于缓存 Long 对象</li>
<li>有 CharacterCache 用于缓存 Character 对象</li>
<li>Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。</li>
</ul>
</li>
</ul>
<h3 id="3-理解自动装箱和拆箱"><a href="#3-理解自动装箱和拆箱" class="headerlink" title="3.理解自动装箱和拆箱"></a>3.理解自动装箱和拆箱</h3><h4 id="3-1-什么是装箱？什么是拆箱？"><a href="#3-1-什么是装箱？什么是拆箱？" class="headerlink" title="3.1 什么是装箱？什么是拆箱？"></a>3.1 什么是装箱？什么是拆箱？</h4><ul>
<li>装箱就是  自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//拆箱</span><br><span class="line">int yc = 5;</span><br><span class="line">//装箱</span><br><span class="line">Integer yc = 5;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-装箱和拆箱是如何实现的"><a href="#3-2-装箱和拆箱是如何实现的" class="headerlink" title="3.2 装箱和拆箱是如何实现的"></a>3.2 装箱和拆箱是如何实现的</h4><ul>
<li><p>以Interger类为例，下面看一段代码来了解装箱和拆箱的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer y = 10;</span><br><span class="line">        int c = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后来编译一下，看下图所示：</p>
<ul>
<li>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。</li>
<li>因此可以用一句话总结装箱和拆箱的实现过程：装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。<br><img src="https://upload-images.jianshu.io/upload_images/4432347-9a3efbd0f681629e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
</li>
</ul>
<h4 id="3-3-装箱和拆箱在编程实际中注意点"><a href="#3-3-装箱和拆箱在编程实际中注意点" class="headerlink" title="3.3 装箱和拆箱在编程实际中注意点"></a>3.3 装箱和拆箱在编程实际中注意点</h4><ul>
<li>建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。</li>
</ul>
<h3 id="4-原始类型线程安全问题"><a href="#4-原始类型线程安全问题" class="headerlink" title="4.原始类型线程安全问题"></a>4.原始类型线程安全问题</h3><h4 id="4-1-那些类型是线程安全的"><a href="#4-1-那些类型是线程安全的" class="headerlink" title="4.1 那些类型是线程安全的"></a>4.1 那些类型是线程安全的</h4><ul>
<li>Java自带的线程安全的基本类型包括： AtomicInteger, AtomicLong, AtomicBoolean, AtomicIntegerArray,AtomicLongArray等</li>
</ul>
<h4 id="4-2-如何验证int类型是否线程安全"><a href="#4-2-如何验证int类型是否线程安全" class="headerlink" title="4.2 如何验证int类型是否线程安全"></a>4.2 如何验证int类型是否线程安全</h4><ul>
<li>200个线程，每个线程对共享变量 count 进行 50 次 ++ 操作 </li>
<li>int 作为基本类型，直接存储在内存栈，且对其进行+,-操作以及++,–操作都不是原子操作，都有可能被其他线程抢断，所以不是线程安全。int 用于单线程变量存取，开销小，速度快</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">50</span>; k++)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 休眠10秒，以确保线程都已启动</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>*<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        Log.e(<span class="string">"打印日志----"</span>,count+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//期望输出10000，最后输出的是9818</span></span><br><span class="line"><span class="comment">//注意：打印日志----: 9818</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-AtomicInteger线程安全版"><a href="#4-3-AtomicInteger线程安全版" class="headerlink" title="4.3 AtomicInteger线程安全版"></a>4.3 AtomicInteger线程安全版</h4><ul>
<li>AtomicInteger类中有有一个变量valueOffset，用来描述AtomicInteger类中value的内存位置 。</li>
<li>当需要变量的值改变的时候，先通过get（）得到valueOffset位置的值，也即当前value的值.给该值进行增加，并赋给next</li>
<li>compareAndSet（）比较之前取到的value的值当前有没有改变，若没有改变的话，就将next的值赋给value，倘若和之前的值相比的话发生变化的话，则重新一次循环，直到存取成功，通过这样的方式能够保证该变量是线程安全的</li>
<li>value使用了volatile关键字，使得多个线程可以共享变量，使用volatile将使得VM优化失去作用，在线程数特别大时，效率会较低。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">static</span> Integer count1 = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">50</span>; k++)&#123;</span><br><span class="line">                    <span class="comment">// getAndIncrement: 先获得值，再自增1，返回值为自增前的值</span></span><br><span class="line">                    count1 = atomicInteger.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 休眠10秒，以确保线程都已启动</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>*<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        Log.e(<span class="string">"打印日志----"</span>,count1+<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//期望输出10000，最后输出的是10000</span></span><br><span class="line"><span class="comment">//注意：打印日志----: 10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//AtomicInteger使用了volatile关键字进行修饰，使得该类可以满足线程安全。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-Java-原始数据类型和引用类型局限性"><a href="#5-Java-原始数据类型和引用类型局限性" class="headerlink" title="5.Java 原始数据类型和引用类型局限性"></a>5.Java 原始数据类型和引用类型局限性</h3><h4 id="5-1-原始数据类型和-Java-泛型并不能配合使用"><a href="#5-1-原始数据类型和-Java-泛型并不能配合使用" class="headerlink" title="5.1 原始数据类型和 Java 泛型并不能配合使用"></a>5.1 原始数据类型和 Java 泛型并不能配合使用</h4><ul>
<li>Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为Object。</li>
</ul>
<h4 id="5-2-无法高效地表达数据，也不便于表达复杂的数据结构"><a href="#5-2-无法高效地表达数据，也不便于表达复杂的数据结构" class="headerlink" title="5.2 无法高效地表达数据，也不便于表达复杂的数据结构"></a>5.2 无法高效地表达数据，也不便于表达复杂的数据结构</h4><ul>
<li>Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</li>
<li>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。</li>
</ul>
<h3 id="6-关于其他知识延伸"><a href="#6-关于其他知识延伸" class="headerlink" title="6.关于其他知识延伸"></a>6.关于其他知识延伸</h3><h4 id="6-1-对象的内存结构"><a href="#6-1-对象的内存结构" class="headerlink" title="6.1 对象的内存结构"></a>6.1 对象的内存结构</h4><ul>
<li>对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</li>
</ul>
<h4 id="6-2-对象头的结构"><a href="#6-2-对象头的结构" class="headerlink" title="6.2 对象头的结构"></a>6.2 对象头的结构</h4><ul>
<li>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为”Mark Word”。</li>
<li>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</li>
</ul>
<h4 id="6-3-如何计算或者获取某个Java对象的大小"><a href="#6-3-如何计算或者获取某个Java对象的大小" class="headerlink" title="6.3 如何计算或者获取某个Java对象的大小"></a>6.3 如何计算或者获取某个Java对象的大小</h4><ul>
<li>获取一个JAVA对象的大小，可以将一个对象进行序列化为二进制的Byte，便可以查看大小</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个JAVA对象的大小，可以将一个对象进行序列化为二进制的Byte，便可以查看大小</span></span><br><span class="line">Integer value = <span class="number">10</span>;</span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos ;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">    oos.writeObject(value);</span><br><span class="line">    oos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读出当前对象的二进制流信息</span></span><br><span class="line">Log.e(<span class="string">"打印日志----"</span>,bos.size()+<span class="string">""</span>);</span><br><span class="line"><span class="comment">//打印日志----: 81</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/07/java/base/06-javaInteger/" data-id="ckkrzb8y2002tcv2axdw0uwe5" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/05/送你一朵小红花/">送你一朵小红花</a>
          </li>
        
          <li>
            <a href="/2020/03/01/base/vim学习/">vim学习</a>
          </li>
        
          <li>
            <a href="/2020/02/23/前端往事/">前端往事</a>
          </li>
        
          <li>
            <a href="/2020/02/10/散文/鲁迅名句摘要/">鲁迅名句摘要</a>
          </li>
        
          <li>
            <a href="/2019/07/18/network/c10k问题/">C10K问题由来</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 popc&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;cc5853235@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>