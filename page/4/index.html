<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>飞翔的企鹅</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这里是介绍">
<meta property="og:type" content="website">
<meta property="og:title" content="飞翔的企鹅">
<meta property="og:url" content="https://blog.okjvm.com/page/4/index.html">
<meta property="og:site_name" content="飞翔的企鹅">
<meta property="og:description" content="这里是介绍">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="飞翔的企鹅">
<meta name="twitter:description" content="这里是介绍">
  
    <link rel="alternate" href="/atom.xml" title="飞翔的企鹅" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.okjvm.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">飞翔的企鹅</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎访问</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java/base/05-javaString" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/06/java/base/05-javaString/" class="article-date">
  <time datetime="2018-11-06T08:12:45.000Z" itemprop="datePublished">2018-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/06/java/base/05-javaString/">05 javaString类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>0.String问题答疑</li>
<li>1.String的创建机理</li>
<li>2.StringBuffer/StringBuilder</li>
<li>3.String类的考点分析</li>
<li>4.String技术点深入分析</li>
<li>5.String不可变的好处</li>
</ul>
<h3 id="0-String问题答疑"><a href="#0-String问题答疑" class="headerlink" title="0.String问题答疑"></a>0.String问题答疑</h3><ul>
<li>String字符串是如何设计与实现考量的？</li>
<li>String字符串缓存 intern()方法，由永久代移到堆中。</li>
<li>String 的演化，Java 9 中底层把 char 数组换成了 byte 数组，占用更少的空间</li>
</ul>
<h3 id="1-String的创建机理"><a href="#1-String的创建机理" class="headerlink" title="1.String的创建机理"></a>1.String的创建机理</h3><ul>
<li>由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举例：String str1 = &quot;123&quot;; //通过直接量赋值方式，放入字符串常量池</span><br><span class="line">String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：String提供了inter()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。</li>
</ul>
<h3 id="2-StringBuffer-StringBuilder"><a href="#2-StringBuffer-StringBuilder" class="headerlink" title="2.StringBuffer/StringBuilder"></a>2.StringBuffer/StringBuilder</h3><ul>
<li>StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口；其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组）进行存储，不同点是StringBuffer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变;两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</li>
</ul>
<h3 id="3-String类的考点分析"><a href="#3-String类的考点分析" class="headerlink" title="3.String类的考点分析"></a>3.String类的考点分析</h3><ul>
<li>通过 String 和相关类，考察基本的线程安全设计与实现，各种基础编程实践。</li>
<li>考察 JVM 对象缓存机制的理解以及如何良好地使用。</li>
<li>考察 JVM 优化 Java 代码的一些技巧。</li>
<li>String 相关类的演进，比如 Java 9 中实现的巨大…</li>
</ul>
<h3 id="4-String技术点深入分析"><a href="#4-String技术点深入分析" class="headerlink" title="4.String技术点深入分析"></a>4.String技术点深入分析</h3><h4 id="4-1-String类是典型的Immutable类"><a href="#4-1-String类是典型的Immutable类" class="headerlink" title="4.1 String类是典型的Immutable类"></a>4.1 String类是典型的Immutable类</h4><ul>
<li>是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。</li>
</ul>
<h4 id="4-2-字符串设计和实现考量"><a href="#4-2-字符串设计和实现考量" class="headerlink" title="4.2 字符串设计和实现考量"></a>4.2 字符串设计和实现考量</h4><ul>
<li>String 是 Immutable 类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</li>
<li>为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。</li>
<li>这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行arraycopy。</li>
</ul>
<h4 id="4-3-字符串缓存"><a href="#4-3-字符串缓存" class="headerlink" title="4.3 字符串缓存"></a>4.3 字符串缓存</h4><ul>
<li>String 在 Java 6 以后提供了 intern()方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。</li>
<li>在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。</li>
</ul>
<h3 id="5-String不可变的好处"><a href="#5-String不可变的好处" class="headerlink" title="5.String不可变的好处"></a>5.String不可变的好处</h3><ul>
<li><strong>5.1 可以缓存 hash 值</strong> <ul>
<li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
</ul>
</li>
<li><strong>5.2 String Pool 的需要</strong> <ul>
<li>如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li>
</ul>
</li>
<li><strong>5.3 安全性</strong> <ul>
<li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
</ul>
</li>
<li><strong>5.4 线程安全</strong> <ul>
<li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/06/java/base/05-javaString/" data-id="ckkrzb8xg001vcv2agf6efmns" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/thread/02-threadDeep" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/05/java/thread/02-threadDeep/" class="article-date">
  <time datetime="2018-11-05T09:54:55.000Z" itemprop="datePublished">2018-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/05/java/thread/02-threadDeep/">多线程深入理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li><strong>1.ThreadPoolExecutor类介绍</strong></li>
<li>1.1 构造函数</li>
<li>1.2 参数解析</li>
<li>1.3 遵循的规则</li>
<li>1.4 使用线程池管理线程的优点</li>
<li><strong>2.关于线程池的分类</strong></li>
<li>2.1 FixedThreadPool</li>
<li>2.2 CachedThreadPool</li>
<li>2.3 ScheduledThreadPool</li>
<li>2.4 SingleThreadExecutor</li>
<li><strong>3.线程池一般用法</strong></li>
<li>3.1 一般方法介绍</li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/05/java/thread/02-threadDeep/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/05/java/thread/02-threadDeep/" data-id="ckkrzb8xn0028cv2a0pxn4fn2" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="page-散文/藤野先生" class="article article-type-page" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/01/散文/藤野先生/" class="article-date">
  <time datetime="2018-11-01T10:24:03.000Z" itemprop="datePublished">2018-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/01/散文/藤野先生/">藤野先生</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>　　东京也无非是这样。上野的樱花烂熳的时节，望去确也像绯红的轻云，但花下也缺不了成群结队的“清国留学生”的速成班，头顶上盘着大辫子，顶得学生制帽的顶上高高耸起，形成一座富士山。也有解散辫子，盘得平的，除下帽来，油光可鉴，宛如小姑娘的发髻一般，还要将脖子扭几扭。实在标致极了。</p>
<p>　　中国留学生会馆的门房里有几本书买，有时还值得去一转；倘在上午，里面的几间洋房里倒也还可以坐坐的。但到傍晚，有一间的地板便常不免要咚咚咚地响得震天，兼以满房烟尘斗乱；问问精通时事的人，答道，“那是在学跳舞。”</p>
<p>　　到别的地方去看看，如何呢？</p>
<p>　　我就往仙台的医学专门学校去。从东京出发，不久便到一处驿站，写道：日暮里。不知怎地，我到现在还记得这名目。其次却只记得水户了，这是明的遗民朱舜水先生客死的地方。仙台是一个市镇，并不大；冬天冷得利害；还没有中国的学生。</p>
<p>　　大概是物以希为贵罢。北京的白菜运往浙江，便用红头绳系住菜根，倒挂在水果店头，尊为“胶菜”；福建野生着的芦荟，一到北京就请进温室，且美其名曰“龙舌兰”。我到仙台也颇受了这样的优待，不但学校不收学费，几个职员还为我的食宿操心。我先是住在监狱旁边一个客店里的，初冬已经颇冷，蚊子却还多，后来用被盖了全身，用衣服包了头脸，只留两个鼻孔出气。在这呼吸不息的地方，蚊子竟无从插嘴，居然睡安稳了。饭食也不坏。但一位先生却以为这客店也包办囚人的饭食，我住在那里不相宜，几次三番，几次三番地说。我虽然觉得客店兼办囚人的饭食和我不相干，然而好意难却，也只得别寻相宜的住处了。于是搬到别一家，离监狱也很远，可惜每天总要喝难以下咽的芋梗汤⑨。</p>
<p>　　从此就看见许多陌生的先生，听到许多新鲜的讲义。解剖学是两个教授分任的。最初是骨学。其时进来的是一个黑瘦的先生，八字须，戴着眼镜，挟着一叠大大小小的书。一将书放在讲台上，便用了缓慢而很有顿挫的声调，向学生介绍自己道：</p>
<p>　　“我就是叫作藤野严九郎⑩的……”</p>
<p>　　后面有几个人笑起来了。他接着便讲述解剖学在日本发达的历史，那些大大小小的书，便是从最初到现今关于这一门学问的著作。起初有几本是线装的；还有翻刻中国译本的，他们的翻译和研究新的医学，并不比中国早。</p>
<p>　　那坐在后面发笑的是上学年不及格的留级学生，在校已经一年，掌故颇为熟悉的了。他们便给新生讲演每个教授的历史。这藤野先生，据说是穿衣服太模胡了，有时竟会忘记带领结；冬天是一件旧外套，寒颤颤的，有一回上火车去，致使管车的疑心他是扒手，叫车里的客人大家小心些。</p>
<p>　　他们的话大概是真的，我就亲见他有一次上讲堂没有带领结。</p>
<p>　　过了一星期，大约是星期六，他使助手来叫我了。到得研究室，见他坐在人骨和许多单独的头骨中间，──他其时正在研究着头骨，后来有一篇论文在本校的杂志上发表出来。</p>
<p>　　“我的讲义，你能抄下来么？”他问。</p>
<p>　　“可以抄一点。”</p>
<p>　　“拿来我看！”</p>
<p>　　我交出所抄的讲义去，他收下了，第二三天便还我，并且说，此后每一星期要送给他看一回。我拿下来打开看时，很吃了一惊，同时也感到一种不安和感激。原来我的讲义已经从头到末，都用红笔添改过了，不但增加了许多脱漏的地方，连文法的错误，也都一一订正。这样一直继续到教完了他所担任的功课：骨学、血管学、神经学。</p>
<p>　　可惜我那时太不用功，有时也很任性。还记得有一回藤野先生将我叫到他的研究室里去，翻出我那讲义上的一个图来，是下臂的血管，指着，向我和蔼的说道：</p>
<p>　　“你看，你将这条血管移了一点位置了。──自然，这样一移，的确比较的好看些，然而解剖图不是美术，实物是那么样的，我们没法改换它。现在我给你改好了，以后你要全照着黑板上那样的画。”</p>
<p>　　但是我还不服气，口头答应着，心里却想道：</p>
<p>　　“图，还是我画的不错。至于实在的情形，我心里自然记得的。”</p>
<p>　　学年试验完毕之后，我便到东京玩了一夏天，秋初再回学校，成绩早已发表了，同学一百余人之中，我在中间，不过是没有落第。这回藤野先生所担任的功课，是解剖实习和局部解剖学。</p>
<p>　　解剖实习了大概一星期，他又叫我去了，很高兴地，仍用了极有抑扬的声调对我说道：</p>
<p>　　“我因为听说中国人是很敬重鬼的，所以很担心，怕你不肯解剖尸体。现在总算放心了，没有这回事。”</p>
<p>　　但他也偶有使我很为难的时候。他听说中国的女人是裹脚的，但不知道详细，所以要问我怎么裹法，足骨变成怎样的畸形，还叹息道：“总要看一看才知道。究竟是怎么一回事呢？”</p>
<p>　　有一天，本级的学生会干事到我寓里来了，要借我的讲义看。我检出来交给他们，却只翻检了一通，并没有带走。但他们一走，邮差就送到一封很厚的信，拆开看时，第一句是：</p>
<p>　　“你改悔罢！”</p>
<p>　　这是《新约》上的句子罢，但经托尔斯泰新近引用过的。其时正值日俄战争，托老先生便写了一封给俄国和日本的皇帝的信，开首便是这一句。日本报纸上很斥责他的不逊，爱国青年也愤然，然而暗地里却早受了他的影响了。其次的话，大略是说上年解剖学试验的题目，是藤野先生在讲义上做了记号，我预先知道的，所以能有这样的成绩。末尾是匿名。</p>
<p>　　我这才回忆到前几天的一件事。因为要开同级会，干事便在黑板上写广告，末一句是“请全数到会勿漏为要”，而且在“漏”字旁边加了一个圈。我当时虽然觉到圈得可笑，但是毫不介意，这回才悟出那字也在讥刺我了，犹言我得了教员漏泄出来的题目。</p>
<p>　　我便将这事告知了藤野先生；有几个和我熟识的同学也很不平，一同去诘责干事托辞检查的无礼，并且要求他们将检查的结果，发表出来。终于这流言消灭了，干事却又竭力运动，要收回那一封匿名信去。结末是我便将这托尔斯泰式的信退还了他们。</p>
<p>　　中国是弱国，所以中国人当然是低能儿，分数在六十分以上，便不是自己的能力了：也无怪他们疑惑。但我接着便有参观枪毙中国人的命运了。第二年添教霉菌学，细菌的形状是全用电影来显示的，一段落已完而还没有到下课的时候，便影几片时事的片子，自然都是日本战胜俄国的情形。但偏有中国人夹在里边：给俄国人做侦探，被日本军捕获，要枪毙了，围着看的也是一群中国人；在讲堂里的还有一个我。</p>
<p>　　“万岁！”他们都拍掌欢呼起来。</p>
<p>　　这种欢呼，是每看一片都有的，但在我，这一声却特别听得刺耳。此后回到中国来，我看见那些闲看枪毙犯人的人们，他们也何尝不酒醉似的喝彩，──呜呼，无法可想！但在那时那地，我的意见却变化了。</p>
<p>　　到第二学年的终结，我便去寻藤野先生，告诉他我将不学医学，并且离开这仙台。他的脸色仿佛有些悲哀，似乎想说话，但竟没有说。</p>
<p>　　“我想去学生物学，先生教给我的学问，也还有用的。”其实我并没有决意要学生物学，因为看得他有些凄然，便说了一个慰安他的谎话。</p>
<p>　　“为医学而教的解剖学之类，怕于生物学也没有什么大帮助。”他叹息说。</p>
<p>　　将走的前几天，他叫我到他家里去，交给我一张照相，后面写着两个字道：“惜别”，还说希望将我的也送他。但我这时适值没有照相了；他便叮嘱我将来照了寄给他，并且时时通信告诉他此后的状况。</p>
<p>　　我离开仙台之后，就多年没有照过相，又因为状况也无聊，说起来无非使他失望，便连信也怕敢写了。经过的年月一多，话更无从说起，所以虽然有时想写信，却又难以下笔，这样的一直到现在，竟没有寄过一封信和一张照片。从他那一面看起来，是一去之后，杳无消息了。</p>
<p>　　但不知怎地，我总还时时记起他，在我所认为我师的之中，他是最使我感激，给我鼓励的一个。有时我常常想：他的对于我的热心的希望，不倦的教诲，小而言之，是为中国，就是希望中国有新的医学；大而言之，是为学术，就是希望新的医学传到中国去。他的性格，在我的眼里和心里是伟大的，虽然他的姓名并不为许多人所知道。</p>
<p>　　他所改正的讲义，我曾经订成三厚本，收藏着的，将作为永久的纪念。不幸七年前迁居的时候，中途毁坏了一口书箱，失去半箱书，恰巧这讲义也遗失在内了。责成运送局去找寻，寂无回信。只有他的照相至今还挂在我北京寓居的东墙上，书桌对面。每当夜间疲倦，正想偷懒时，仰面在灯光中瞥见他黑瘦的面貌，似乎正要说出抑扬顿挫的话来，便使我忽又良心发现，而且增加勇气了，于是点上一枝烟，再继续写些为“正人君子”之流所深恶痛疾的文字。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/01/散文/藤野先生/" data-id="ckkrzb8x7001ncv2ac75a20ke" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/鲁迅/">鲁迅</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/thread/01-threadBase" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/01/java/thread/01-threadBase/" class="article-date">
  <time datetime="2018-11-01T09:54:54.000Z" itemprop="datePublished">2018-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/01/java/thread/01-threadBase/">多线程基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="多线程基础知识"><a href="#多线程基础知识" class="headerlink" title="多线程基础知识"></a>多线程基础知识</h4><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li><strong>0.先来看几个问题[思考]</strong></li>
<li><strong>1.进程概述及多进程的意义[理解]</strong><ul>
<li>1.1 线程和进程</li>
<li>1.2 进程概述</li>
<li>1.3 多进程的意义</li>
</ul>
</li>
<li><strong>2.线程的概述和多线程的意义[理解]</strong><ul>
<li>2.1 什么是线程</li>
<li>2.2 多线程有什么意义</li>
<li>2.3 并行和并发</li>
</ul>
</li>
<li><strong>3.JVM运行原理以及JVM启动的线程探讨[理解]</strong><ul>
<li>3.1 Java程序运行原理</li>
<li>3.2 JVM的启动是多线程的吗</li>
</ul>
</li>
<li><strong>4.多线程程序实现的方式[掌握]</strong><ul>
<li><strong>4.1 多线程程序实现的方式【重点】</strong></li>
</ul>
<ul>
<li>4.1.1 第一种方式：是类继承Thread</li>
<li>4.1.2 第二种方式：是实现接口Runnable</li>
<li>4.2 多线程两种方式的区别</li>
<li>4.3 几个小问题探索</li>
<li>4.4 匿名内部类的方式实现多线程程序</li>
</ul>
</li>
<li><strong>5.线程调度</strong><ul>
<li>5.1 线程的调度问题</li>
<li>5.2 线程有两种调度模型</li>
</ul>
</li>
<li><strong>6.线程控制</strong><ul>
<li>6.1 线程控制之休眠线程</li>
<li>6.2 线程控制之加入线程</li>
<li>6.3 线程控制之礼让线程</li>
<li>6.4 线程控制之守护线程</li>
<li>6.5 线程控制之中断线程</li>
</ul>
</li>
<li><strong>7.案例分析</strong><ul>
<li>7.1 继承Thread类的方式卖电影票案例</li>
<li>7.2 实现Runnable接口的方式卖电影票</li>
<li>7.3 买电影票出现了同票和负数票的原因分析</li>
<li>7.4 线程安全问题的产生原因分析</li>
<li>7.5 同步代码块的方式解决线程安全问题</li>
</ul>
</li>
<li><strong>8.关于思考问题解答</strong></li>
</ul>
        
          <p class="article-more-link">
            <a href="/2018/11/01/java/thread/01-threadBase/#more">继续阅读全文 »</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/11/01/java/thread/01-threadBase/" data-id="ckkrzb8yj003jcv2agfqxaa4b" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/多线程/">多线程</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/10-memoryAllocationAndLeakage" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/21/java/base/10-memoryAllocationAndLeakage/" class="article-date">
  <time datetime="2018-10-21T08:42:22.000Z" itemprop="datePublished">2018-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/21/java/base/10-memoryAllocationAndLeakage/">java内存分配和泄露</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><strong>Java内存分配机制及内存泄漏</strong><br><strong>目录介绍</strong></p>
<ul>
<li><strong>1.JVM内存管理</strong></li>
<li>1.1 JVM内存管理图</li>
<li>1.2 Java采用GC进行内存管理。</li>
<li><strong>2.JVM内存分配的几种策略</strong></li>
<li>2.1 静态的</li>
<li>2.2 栈式的</li>
<li>2.3 堆式的</li>
<li>2.4 堆和栈的区别</li>
<li>2.5 得出结论</li>
<li>2.6 举个例子</li>
<li>2.7 调用 System.gc();进行内存回收</li>
<li><strong>3.GC简单介绍</strong></li>
<li>3.1 内存垃圾回收机制</li>
<li>3.2 关于GC介绍</li>
<li>3.3 如何监听GC过程</li>
<li>3.4 GC过程与对象的引用类型关系</li>
<li><strong>4.内存泄漏简单介绍</strong></li>
<li>4.1 内存泄漏的定义</li>
<li>4.2 内存泄漏与内存溢出的区别</li>
<li>4.3 内存泄漏带来的影响</li>
<li>4.4 典型内存泄漏案例</li>
<li><strong>5.GC回收机制</strong></li>
<li>5.1 GC回收机制</li>
<li>5.2 内存分配</li>
<li>5.3 垃圾回收思路及方法<ul>
<li>检测垃圾的算法<ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
</ul>
</li>
<li>处理垃圾的算法<ul>
<li>1.标记-清除（Mark-sweep）</li>
<li>2.复制（Copying）</li>
<li>3.标记-整理（Mark-Compact）</li>
<li>4.分代收集算法(当今最常用的方法)</li>
</ul>
</li>
</ul>
</li>
<li>5.4 如何对对象划分<ul>
<li>将对象按其生命周期划分</li>
<li>年轻代</li>
<li>年老代</li>
</ul>
</li>
<li>5.5  GC中对象的六种可触及状态</li>
</ul>
<h3 id="1-JVM内存管理"><a href="#1-JVM内存管理" class="headerlink" title="1.JVM内存管理"></a>1.JVM内存管理</h3><p><strong>1.1 JVM内存管理</strong><br><img src="/images/4432347-d11c55cea858b5e4.png" alt=""></p>
<p><strong>1.2 Java采用GC进行内存管理。</strong></p>
<ul>
<li>Android虚拟机的垃圾回收采用的是根搜索算法。GC会从根节点（GC Roots）开始对heap进行遍历。到最后，部分没有直接或者间接引用到GC Roots的就是需要回收的垃圾，会被GC回收掉。而内存泄漏出现的原因就是存在了无效的引用，导致本来需要被GC的对象没有被回收掉。</li>
<li>深入的JVM内存管理知识，推荐《深入理解Java虚拟机》。</li>
</ul>
<h3 id="2-JVM内存分配的几种策略。"><a href="#2-JVM内存分配的几种策略。" class="headerlink" title="2.JVM内存分配的几种策略。"></a>2.JVM内存分配的几种策略。</h3><p><strong>2.1 静态的</strong></p>
<ul>
<li>静态的存储区，内存在程序编译的时候就已经分配好了，这块内存在程序整个运行期间都一直存在<br>它主要存放静态数据、全局的static数据和一些常量。</li>
</ul>
<p><strong>2.2 栈式的</strong></p>
<ul>
<li>在执行方法时，方法一些内部变量的存储都可以放在栈上面创建，方法执行结束的时候这些存储单元就会自动被注释掉。栈 内存包括分配的运算速度很快，因为内在在处理器里面。当然容量有限，并且栈式一块连续的内存区域，大小是由操作系统决定的，他先进后出，进出完成不会产生碎片，运行效率高且稳定</li>
</ul>
<p><strong>2.3 堆式的</strong></p>
<ul>
<li>也叫动态内存 。我们通常使用new 来申请分配一个内存。这里也是我们讨论内存泄漏优化的关键存储区。GC会根据内存的使用情况，对堆内存里的垃圾内存进行回收。堆内存是一块不连续的内存区域，如果频繁地new/remove会造成大量的内存碎片，GC频繁的回收，导致内存抖动，这也会消耗我们应用的性能</li>
</ul>
<p><strong>2.4 堆和栈的区别</strong></p>
<ul>
<li>在函数中（说明是局部变量）定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。</li>
<li>当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</li>
<li>堆内存用于存放所有由new创建的对象（内容包括该对象其中的所有成员变量）和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。</li>
<li>在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。</li>
</ul>
<p><strong>2.5 得出结论</strong></p>
<ul>
<li>1.局部变量的基本数据类型和引用，存储于栈中，引用的对象实体存储于堆中。因为它们属于方法中的变量，生命周期随方法而结束。</li>
<li>2.成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体），因为它们属于类，类对象终究是要被new出来使用的。</li>
<li>3.我们所说的内存泄露，只针对堆内存，他们存放的就是引用指向的对象实体。</li>
</ul>
<p><strong>2.6 举个例子</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Sample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">    Sample mSample1 = <span class="keyword">new</span> Sample();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">1</span>;</span><br><span class="line">        Sample mSample2 = <span class="keyword">new</span> Sample();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Sample mSample3 = <span class="keyword">new</span> Sample();</span><br><span class="line">Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。</span><br><span class="line">mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。</span><br></pre></td></tr></table></figure></p>
<p><strong>2.7 调用 System.gc();进行内存回收</strong></p>
<ul>
<li>我们知道可以调用 System.gc();进行内存回收，但是GC不一定会执行。面对GC的机制，我们是否无能为力？其实我们可以通过声明一些引用标记来让GC更好对内存进行回收。</li>
<li><img src="/images/443234711d8e58df3b16a042.png" alt=""></li>
<li>小技巧</li>
<li>成员变量全部存储在堆中（包括基本数据类型，引用及引用的对象实体），因为他们属于类，类对象最终还是要被new出来的</li>
<li>局部变量的基本数据类型和引用存在栈中，应用的对象实体存储在堆中。因为它们属于方法当中的变量，生命周期会随着方法一起结束</li>
</ul>
<h3 id="3-GC工作原理"><a href="#3-GC工作原理" class="headerlink" title="3.GC工作原理"></a>3.GC工作原理</h3><p><strong>3.1 内存垃圾回收机制</strong></p>
<ul>
<li>是从程序的主要运行对象(如静态对象/寄存器/栈上指向的堆内存对象等)开始检查引用链，当遍历一遍后得到上述这些无法回收的对象和他们所引用的对象链，组成无法回收的对象集合，而其他孤立对象（集）就作为垃圾回收</li>
<li>GC为了能够正确释放对象，必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</li>
</ul>
<p><strong>3.2 关于GC介绍</strong></p>
<ul>
<li>有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义，该函数不保证JVM的垃圾收集器一定会执行。因为不同的JVM实现者可能使用不同的算法管理GC</li>
<li>通常GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。<br><strong>通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间</strong></li>
</ul>
<p><strong>3.3 如何监听GC过程</strong></p>
<ul>
<li>系统每进行一次GC操作时，都会在LogCat中打印一条日志，我们只要去分析这条日志就可以了，日志的基本格式如下<br><strong>D/dalvikvm: &lt;GC_Reason&gt; &lt;Amount_freed&gt;, &lt;Heap_stats&gt;,  &lt;Pause_time&gt;</strong></li>
<li><p>第一部分GC_Reason，这个是触发这次GC操作的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原因，一般情况下一共有以下几种触发GC操作的原因：</span><br><span class="line">- GC_CONCURRENT: 当我们应用程序的堆内存快要满的时候，系统会自动触发GC操作来释放内存。</span><br><span class="line">- GC_FOR_MALLOC: 当我们的应用程序需要分配更多内存，可是现有内存已经不足的时候，系统会进行GC操作来释放内存。</span><br><span class="line">- GC_HPROF_DUMP_HEAP: 当生成HPROF文件的时候，系统会进行GC操作，关于HPROF文件我们下面会讲到。</span><br><span class="line">- GC_EXPLICIT: 这种情况就是我们刚才提到过的，主动通知系统去进行GC操作，比如调用System.gc()方法来通知系统。或者在DDMS中，通过工具按钮也是可以显式地告诉系统进行GC操作的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二部分Amount_freed，表示系统通过这次GC操作释放了多少内存</p>
</li>
<li>第三部分Heap_stats中会显示当前内存的空闲比例以及使用情况（活动对象所占内存 / 当前程序总内存）</li>
<li>第四部分Pause_time表示这次GC操作导致应用程序暂停的时间。关于这个暂停的时间，Android在2.3的版本当中进行过一次优化，在2.3之前GC操作是不能并发进行的，也就是系统正在进行GC，那么应用程序就只能阻塞住等待GC结束。虽说这个阻塞的过程并不会很长，也就是几百毫秒，但是用户在使用我们的程序时还是有可能会感觉到略微的卡顿。而自2.3之后，GC操作改成了并发的方式进行，就是说GC的过程中不会影响到应用程序的正常运行，但是在GC操作的开始和结束的时候会短暂阻塞一段时间，不过优化到这种程度，用户已经是完全无法察觉到了</li>
</ul>
<p><strong>3.4 GC过程与对象的引用类型关系</strong><br>Java对引用的分类Strong reference, SoftReference, WeakReference, PhatomReference</p>
<p><img src="/images/4432347-46caa86083269dc9.png" alt=""></p>
<ul>
<li>软引用和弱引用</li>
<li>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术</li>
<li>软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</li>
<li>利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。</li>
<li>内存泄漏的原因：堆内存中的长生命周期的对象持有短生命周期对象的强/软引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的根本原因</li>
</ul>
<h3 id="4-内存泄漏简单介绍"><a href="#4-内存泄漏简单介绍" class="headerlink" title="4.内存泄漏简单介绍"></a>4.内存泄漏简单介绍</h3><p><strong>4.1 内存泄漏的定义</strong><br>当一个对象已经不需要使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用，从而导致了对象不能被GC回收。这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏</p>
<p><strong>4.2 内存泄漏与内存溢出的区别</strong></p>
<ul>
<li>内存泄漏（Memory Leak）<ul>
<li>进程中某些对象已经没有使用的价值了，但是他们却还可以直接或间接地被引用到GC Root导致无法回收。当内存泄漏过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM</li>
</ul>
</li>
<li>内存溢出（OOM）<ul>
<li>当应用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出</li>
</ul>
</li>
</ul>
<p><strong>4.3 内存泄漏带来的影响</strong></p>
<ul>
<li>应用卡顿<ul>
<li>泄漏的内存影响了GC的内存分配，过多的内存泄漏会影响应用的执行效率</li>
</ul>
</li>
<li>应用异常（OOM）<ul>
<li>过多的内存泄漏，最终会导致 Dalvik分配的内存，出现OOM</li>
</ul>
</li>
</ul>
<p><strong>4.4 典型内存泄漏案例</strong></p>
<ul>
<li><p>案例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析</p>
<ul>
<li>在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</li>
</ul>
</li>
</ul>
<h3 id="5-GC回收机制"><a href="#5-GC回收机制" class="headerlink" title="5.GC回收机制"></a>5.GC回收机制</h3><h4 id="5-1-GC回收机制"><a href="#5-1-GC回收机制" class="headerlink" title="5.1 GC回收机制"></a>5.1 GC回收机制</h4><ul>
<li>在了解回收机制之前，必须要了解内存<ul>
<li>先思考三个问题<ul>
<li>JVM是怎么分配内存的</li>
<li>识别哪些内存是垃圾需要回收</li>
<li>最后才是用什么方式回收</li>
</ul>
</li>
<li>栈的内存管理是顺序分配的，而且定长，不存在内存回收问题；而堆 则是为java对象的实例随机分配内存，不定长度，所以存在内存分配和回收的问题</li>
</ul>
</li>
</ul>
<h4 id="5-2-内存分配"><a href="#5-2-内存分配" class="headerlink" title="5.2 内存分配"></a>5.2 内存分配</h4><ul>
<li>Java虚拟机是先一次性分配一块较大的空间，然后每次new时都在该空间上进行分配和释放，减少了系统调用的次数，节省了一定的开销，这有点类似于内存池的概念；二是有了这块空间过后，如何进行分配和回收就跟GC机制有关了。</li>
<li>java一般内存申请有两种：静态内存和动态内存 。很容易理解，编译时就能够确定的内存就是静态内存，即内存是固定的，系统一次性分配，比如int类型变量；动态内存分配就是在程序执行时才知道要分配的存储空间大小，比如java对象的内存空间。</li>
</ul>
<h4 id="5-3-垃圾回收思路及方法"><a href="#5-3-垃圾回收思路及方法" class="headerlink" title="5.3 垃圾回收思路及方法"></a>5.3 垃圾回收思路及方法</h4><ul>
<li>垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。怎么检测出垃圾？一般有以下几种方法：<ul>
<li>检测垃圾的算法<ul>
<li>a.引用计数法：<ul>
<li>给一个对象添加引用计数器，每当有个地方引用它，计数器就加1；引用失效就减1。好了，问题来了，如果我有两个对象A和B，互相引用，除此之外，没有其他任何对象引用它们，实际上这两个对象已经无法访问，即是我们说的垃圾对象。但是互相引用，计数不为0，导致无法回收</li>
</ul>
</li>
<li>b.可达性分析算法<ul>
<li>以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象，本地方法中引用的对象等</li>
</ul>
</li>
</ul>
</li>
<li>处理垃圾的算法<ul>
<li>1.标记-清除（Mark-sweep）<ul>
<li>算法和名字一样，分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。</li>
<li>不足：效率低；标记清除之后会产生大量碎片。</li>
</ul>
</li>
<li>2.复制（Copying）<ul>
<li>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。 </li>
</ul>
</li>
<li>3.标记-整理（Mark-Compact）<ul>
<li>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 </li>
</ul>
</li>
<li>4.分代收集算法(当今最常用的方法)<ul>
<li>这是当前商业虚拟机常用的垃圾收集算法。分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</li>
<li>为什么要运用分代垃圾回收策略？在java程序运行的过程中，会产生大量的对象，因每个对象所能承担的职责不同所具有的功能不同所以也有着不一样的生命周期，有的对象生命周期较长，比如Http请求中的Session对象，线程，Socket连接等；有的对象生命周期较短，比如String对象，由于其不变类的特性，有的在使用一次后即可回收。试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，那么消耗的时间相对会很长，而且对于存活时间较长的对象进行的扫描工作等都是徒劳。因此就需要引入分治的思想，所谓分治的思想就是因地制宜，将对象进行代的划分，把不同生命周期的对象放在不同的代上使用不同的垃圾回收方式。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-4-如何对对象划分"><a href="#5-4-如何对对象划分" class="headerlink" title="5.4 如何对对象划分"></a>5.4 如何对对象划分</h4><ul>
<li>将对象按其生命周期划分<ul>
<li>年轻代(Young Generation)</li>
<li>年老代(Old Generation)</li>
<li>持久代(Permanent Generation)</li>
<li>其中持久代主要存放的是类信息，所以与java对象的回收关系不大，与回收息息相关的是年轻代和年老代。</li>
<li>年轻代<ul>
<li>是所有新对象产生的地方。</li>
<li>年轻代被分为3个部分——Enden区和两个Survivor区（From和to）</li>
<li>当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区（假设为from区）。Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区（假设为to区）。这样在一段时间内，总会有一个空的survivor区。经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。需要注意，Survivor的两个区是对称的，没先后关系，from和to是相对的。</li>
</ul>
</li>
<li>年老代<ul>
<li>在年轻代中经历了N次回收后仍然没有被清除的对象，就会被放到年老代中，可以说他们都是久经沙场而不亡的一代，都是生命周期较长的对象。对于年老代和永久代，就不能再采用像年轻代中那样搬移腾挪的回收算法，因为那些对于这些回收战场上的老兵来说是小儿科。这时候MajsorGC会清理些老年代垃圾，通常会在老年代内存被占满时将会触发Full GC,回收整个堆内存。</li>
<li>持久代：用于存放静态文件，比如java类、方法等。持久代对垃圾回收没有显著的影响。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-5-GC中对象的六种可触及状态"><a href="#5-5-GC中对象的六种可触及状态" class="headerlink" title="5.5  GC中对象的六种可触及状态"></a>5.5  GC中对象的六种可触及状态</h4><ul>
<li>1.强可触及：对象可以从根结点不通过任何引用对象搜索到</li>
<li>2.软可触及：对象不是强可触及的，但是可以从根结点开始通过一个或多个（未被清除的）软引用对象触及</li>
<li>3.弱可触及：对象既不是强可触及也不是软可触及的，但是从根结点开始</li>
<li>4.可复活的：对象既不是强可触及、软可触及，也不是弱可触及，但是仍然可能通过执行某些终结方法复活到这几种状态之一</li>
<li>5.影子可触及：不上以上任何可触及状态，也不能通过终结方法复活，并且它可以从根结点开始通过一个或多个影子引用对象触及（影子引用不会被垃圾收集器清除，由程序明确地清除）</li>
<li>6.不可触及：就是已经准备回收的状态</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/10/21/java/base/10-memoryAllocationAndLeakage/" data-id="ckkrzb8yg003bcv2a6k2pcqnz" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/09-HashAndHashCode" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/20/java/base/09-HashAndHashCode/" class="article-date">
  <time datetime="2018-10-20T09:39:37.000Z" itemprop="datePublished">2018-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/20/java/base/09-HashAndHashCode/">03.Hash和HashCode深入理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.Hash的作用介绍<ul>
<li>1.1 Hash的定义</li>
<li>1.2 Hash函数特性</li>
<li>1.3 Hash的使用场景</li>
</ul>
</li>
<li>2.如何判断两个对象相等<ul>
<li>2.1 判断两个字符串</li>
<li>2.2 判断两个int数值</li>
<li>2.3 其他基本类型</li>
</ul>
</li>
<li>3.HashCode深入分析<ul>
<li>3.0 HashCode是什么</li>
<li>3.1 为什么要重写HashCode</li>
<li>3.2 HashCode源代码分析</li>
<li>3.3 HashCode带来的疑问</li>
<li>3.4 HashCode的作用</li>
<li>3.5 HashMap中的HashCode</li>
<li>3.6 可直接用hashcode判断两个对象是否相等</li>
</ul>
</li>
<li>4.Hash表是什么<ul>
<li>4.1 Hash表定义</li>
<li>4.2 Hash表简单介绍</li>
</ul>
</li>
<li>5.Hash中的算法应用<ul>
<li>5.1 基础算法</li>
<li>5.2 经典算法[摘自网络]</li>
<li>5.3 Hash碰撞[摘自网络]</li>
</ul>
</li>
<li>6.Hash在Java中的应用场景<ul>
<li>6.1 equals与hashCode有两个注意点</li>
<li>6.2 以HashSet为例说明hashCode()的作用</li>
<li>6.3 以HashMap为例说明Hash的作用</li>
<li>6.4 </li>
</ul>
</li>
<li>7.版本更新情况</li>
<li>8.其他介绍</li>
</ul>
<h3 id="1-Hash的作用介绍"><a href="#1-Hash的作用介绍" class="headerlink" title="1.Hash的作用介绍"></a>1.Hash的作用介绍</h3><h4 id="1-1-Hash的定义"><a href="#1-1-Hash的定义" class="headerlink" title="1.1 Hash的定义"></a>1.1 Hash的定义</h4><ul>
<li>散列（哈希）函数<ul>
<li>把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值，是一种压缩映射。</li>
<li>或者说一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>
</ul>
</li>
</ul>
<h4 id="1-2-Hash函数特性"><a href="#1-2-Hash函数特性" class="headerlink" title="1.2 Hash函数特性"></a>1.2 Hash函数特性</h4><ul>
<li>h(k1)≠h(k2)则k1≠k2，即散列值不相同，则输入值即预映射不同<ul>
<li>如果k1≠k2，h(k1)=h(k2) 则发生碰撞；</li>
<li>如果h(k1)=h(k2)，k1不一定等于k2；</li>
</ul>
</li>
</ul>
<h4 id="1-3-Hash的使用场景"><a href="#1-3-Hash的使用场景" class="headerlink" title="1.3 Hash的使用场景"></a>1.3 Hash的使用场景</h4><ul>
<li>比如说我们下载一个文件，文件的下载过程中会经过很多网络服务器、路由器的中转，如何保证这个文件就是我们所需要的呢？我们不可能去一一检测这个文件的每个字节，也不能简单地利用文件名、文件大小这些极容易伪装的信息，这时候，就需要一种指纹一样的标志来检查文件的可靠性，这种指纹就是我们现在所用的Hash算法(也叫散列算法)。</li>
<li>散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</li>
<li>这种标志有何意义呢？之前文件下载过程就是一个很好的例子，事实上，现在大部分的网络部署和版本控制工具都在使用散列算法来保证文件可靠性。</li>
</ul>
<h3 id="2-如何判断两个对象相等"><a href="#2-如何判断两个对象相等" class="headerlink" title="2.如何判断两个对象相等"></a>2.如何判断两个对象相等</h3><h4 id="2-1-判断两个字符串"><a href="#2-1-判断两个字符串" class="headerlink" title="2.1 判断两个字符串"></a>2.1 判断两个字符串</h4><ul>
<li><p>使用equals方法判断两个字符串是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"yc1"</span>;</span><br><span class="line">String b = <span class="string">"yc2"</span>;</span><br><span class="line"><span class="keyword">boolean</span> isEqual = a.equals(b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然Object的子类可以通过重写equals的方法，实现子类自身的对象是否相等的逻辑；String是Object的子类，查看下它的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Object类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接比较的是地址</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在String类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接比较的是地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//盘旋是否是字符串String类型</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        <span class="keyword">int</span> n = count;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.count) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//循环判断每个字符是否相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charAt(i) != anotherString.charAt(i))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-判断两个int数值"><a href="#2-2-判断两个int数值" class="headerlink" title="2.2 判断两个int数值"></a>2.2 判断两个int数值</h4><ul>
<li>Integer类的equals方法又是如何实现的呢？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer a = Integer.valueOf(<span class="string">"1"</span>);</span><br><span class="line">Integer b = Integer.valueOf(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">boolean</span> ab = a.equals(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断是否是Integer类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="comment">//转为int值后进行比较</span></span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-3-其他基本类型"><a href="#2-3-其他基本类型" class="headerlink" title="2.3 其他基本类型"></a>2.3 其他基本类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//short类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Short.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">short</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Byte类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Byte.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Long类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//long类型作为索引范围太大，需要转为int类型。这里简单的获取低32位容易导致散列不均，因为高位部分没有被利用。所以这里采用逻辑右移32位，让高32位和低32位进行XOR操作，导致高位低位都能被利用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Boolean类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Boolean.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用两个质数作为true或false的索引。这两个质数足够大，用来作为索引时，出现碰撞的可能性低。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-HashCode深入分析"><a href="#3-HashCode深入分析" class="headerlink" title="3.HashCode深入分析"></a>3.HashCode深入分析</h3><h4 id="3-0-HashCode是什么"><a href="#3-0-HashCode是什么" class="headerlink" title="3.0 HashCode是什么"></a>3.0 HashCode是什么</h4><ul>
<li>HashCode是Object的一个方法，hashCode方法返回一个hash code值，且这个方法是为了更好的支持hash表，比如String，Set，HashTable、HashMap等;</li>
</ul>
<h4 id="3-1-为什么要重写HashCode"><a href="#3-1-为什么要重写HashCode" class="headerlink" title="3.1 为什么要重写HashCode"></a>3.1 为什么要重写HashCode</h4><ul>
<li>如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次equal去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上</li>
</ul>
<h4 id="3-2-HashCode源代码分析"><a href="#3-2-HashCode源代码分析" class="headerlink" title="3.2 HashCode源代码分析"></a>3.2 HashCode源代码分析</h4><ul>
<li><p>在Object中的HashCode源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lockWord = shadow$_monitor_;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lockWordStateMask = <span class="number">0xC0000000</span>; <span class="comment">// Top 2 bits.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lockWordStateHash = <span class="number">0x80000000</span>; <span class="comment">// Top 2 bits are value 2 (kStateHash).</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lockWordHashMask = <span class="number">0x0FFFFFFF</span>; <span class="comment">// Low 28 bits.</span></span><br><span class="line">    <span class="keyword">if</span> ((lockWord &amp; lockWordStateMask) == lockWordStateHash) &#123;</span><br><span class="line">        <span class="keyword">return</span> lockWord &amp; lockWordHashMask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回的是对象引用地址</span></span><br><span class="line">    <span class="keyword">return</span> System.identityHashCode(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在String中的HashCode源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Integer中的HashCode源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-3-HashCode带来的疑问"><a href="#3-3-HashCode带来的疑问" class="headerlink" title="3.3 HashCode带来的疑问"></a>3.3 HashCode带来的疑问</h4><ul>
<li>为何重写equals建议同时重写hashCode？</li>
<li>hashCode是什么？</li>
<li>hashCode作用？</li>
<li>hash code（hash值）是什么？</li>
<li>hash table（hash表）是什么？</li>
<li>hashCode方法对hash表有益处？</li>
<li>hashCode方法对不是hash有益处吗?</li>
</ul>
<h4 id="3-4-HashCode的作用"><a href="#3-4-HashCode的作用" class="headerlink" title="3.4 HashCode的作用"></a>3.4 HashCode的作用</h4><ul>
<li>减少查找次数，提高程序效率<ul>
<li>例如查找是否存在重复值<ul>
<li>h(k1)≠h(k2)则k1≠k2</li>
<li>首先查看h(k2)输出值（内存地址），查看该内存地址是否存在值；</li>
<li>如果无，则表示该值不存在重复值；</li>
<li>如果有，则进行值比较，相同则表示该值已经存在散列列表中，如果不相同则再进行一个一个值比较；而无需一开始就一个一个值的比较，减少了查找次数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-HashMap中的HashCode"><a href="#3-5-HashMap中的HashCode" class="headerlink" title="3.5 HashMap中的HashCode"></a>3.5 HashMap中的HashCode</h4><ul>
<li>在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</li>
<li>为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？<strong>（注意：集合中不允许重复的元素存在）</strong><ul>
<li>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。</li>
<li>此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。下面这段代码是java.util.HashMap的中put方法的具体实现：</li>
</ul>
</li>
<li>put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-6-可直接用hashcode判断两个对象是否相等"><a href="#3-6-可直接用hashcode判断两个对象是否相等" class="headerlink" title="3.6 可直接用hashcode判断两个对象是否相等"></a>3.6 可直接用hashcode判断两个对象是否相等</h4><ul>
<li>肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。</li>
<li>也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；<ul>
<li>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；</li>
<li>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；</li>
<li>如果两个对象的hashcode值相等，则equals方法得到的结果未知。</li>
</ul>
</li>
</ul>
<h3 id="4-Hash表是什么"><a href="#4-Hash表是什么" class="headerlink" title="4.Hash表是什么"></a>4.Hash表是什么</h3><h4 id="4-1-Hash表定义"><a href="#4-1-Hash表定义" class="headerlink" title="4.1 Hash表定义"></a>4.1 Hash表定义</h4><ul>
<li>根据关键码值（KEY-VALUE）而直接进行访问的数据结构；它通过把关键码值（KEY-VALUE）映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</li>
</ul>
<h4 id="4-2-Hash表简单介绍"><a href="#4-2-Hash表简单介绍" class="headerlink" title="4.2 Hash表简单介绍"></a>4.2 Hash表简单介绍</h4><ul>
<li>将k作为输入值，h(k)输出值作为内存地址，该内存地址用来存放value，然后可以通过k获取到value存放的地址，从而获取value信息。</li>
</ul>
<h3 id="5-Hash中的算法应用"><a href="#5-Hash中的算法应用" class="headerlink" title="5.Hash中的算法应用"></a>5.Hash中的算法应用</h3><h4 id="5-1-基础算法"><a href="#5-1-基础算法" class="headerlink" title="5.1 基础算法"></a>5.1 基础算法</h4><ul>
<li>比如，Java中的String.hashCode使用乘法和加法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//乘法与加法</span></span><br><span class="line">            h = <span class="number">31</span> * h + charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-经典算法-摘自网络"><a href="#5-2-经典算法-摘自网络" class="headerlink" title="5.2 经典算法[摘自网络]"></a>5.2 经典算法[摘自网络]</h4><ul>
<li>MD4，MD5，SHA-1或SHA-2等其他</li>
</ul>
<h4 id="5-3-Hash碰撞-摘自网络"><a href="#5-3-Hash碰撞-摘自网络" class="headerlink" title="5.3 Hash碰撞[摘自网络]"></a>5.3 Hash碰撞[摘自网络]</h4><ul>
<li>hash是存在碰撞的，如果k1≠k2，h(k1)=h(k2) 则发生碰撞；</li>
</ul>
<h3 id="6-Hash在Java中的应用场景"><a href="#6-Hash在Java中的应用场景" class="headerlink" title="6.Hash在Java中的应用场景"></a>6.Hash在Java中的应用场景</h3><h4 id="6-1-equals与hashCode有两个注意点"><a href="#6-1-equals与hashCode有两个注意点" class="headerlink" title="6.1 equals与hashCode有两个注意点"></a>6.1 equals与hashCode有两个注意点</h4><ul>
<li>equals相同，则hashCode相同；而hashCode相同，equals不一定相同<ul>
<li>如果equals相同，hashCode不相同，有可能会造成上述重复值等情况，这种情况是不允许的；</li>
<li>而hasCode相同，但是equals不一定相同，有可能是因为发生了碰撞而碰撞是有可能性发生的</li>
</ul>
</li>
</ul>
<h4 id="6-2-以HashSet为例说明hashCode-的作用"><a href="#6-2-以HashSet为例说明hashCode-的作用" class="headerlink" title="6.2 以HashSet为例说明hashCode()的作用"></a>6.2 以HashSet为例说明hashCode()的作用</h4><ul>
<li>假设，HashSet中已经有1000个元素。当插入第1001个元素时，需要怎么处理？<ul>
<li>因为HashSet是Set集合，它不允许有重复元素。“将第1001个元素逐个的和前面1000个元素进行比较”？</li>
<li>显然，这个效率是相等低下的。散列表很好的解决了这个问题，它根据元素的散列码计算出元素在散列表中的位置，然后将元素插入该位置即可。对于相同的元素，自然是只保存了一个。</li>
<li>由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中，<ul>
<li>1、如果两个对象相等，那么它们的hashCode()值一定要相同；</li>
<li>2、如果两个对象hashCode()相等，它们并不一定相等。</li>
<li>注意：这是在散列表中的情况。在非散列表中一定如此！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-3-以HashMap为例说明Hash的作用"><a href="#6-3-以HashMap为例说明Hash的作用" class="headerlink" title="6.3 以HashMap为例说明Hash的作用"></a>6.3 以HashMap为例说明Hash的作用</h4><ul>
<li>在HashMap中有许多地方用到了hash算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这几个方法都用到了这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//计算hashCode，并无符号移动到低位</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">举个例子: h = <span class="number">363771819</span>^(<span class="number">363771819</span> &gt;&gt;&gt; <span class="number">16</span>)</span><br><span class="line"><span class="number">0001</span> <span class="number">0101</span> <span class="number">1010</span> <span class="number">1110</span> <span class="number">1011</span> <span class="number">0111</span> <span class="number">1010</span> <span class="number">1011</span>(<span class="number">363771819</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0101</span> <span class="number">1010</span> <span class="number">1110</span>(<span class="number">5550</span>) XOR</span><br><span class="line">--------------------------------------- =</span><br><span class="line"><span class="number">0001</span> <span class="number">0101</span> <span class="number">1010</span> <span class="number">1110</span> <span class="number">1010</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0101</span>(<span class="number">363766277</span>)</span><br><span class="line">这样做可以实现了高地位更加均匀地混到一起</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul>
<li>Java Hash 存储机制：<a href="http://blog.chinaunix.net/uid-26981819-id-4462638.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26981819-id-4462638.html</a></li>
<li>数据结构之哈希表：<a href="https://www.cnblogs.com/s-b-b/p/6208565.html" target="_blank" rel="noopener">https://www.cnblogs.com/s-b-b/p/6208565.html</a></li>
<li>Java hashCode() 和 equals()的若干问题解答：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li>
<li>Hash算法总结：<a href="https://blog.csdn.net/asdzheng/article/details/70226007" target="_blank" rel="noopener">https://blog.csdn.net/asdzheng/article/details/70226007</a></li>
<li>浅谈Java中的hashcode方法：<a href="http://www.cnblogs.com/dolphin0520/p/3681042.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3681042.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/10/20/java/base/09-HashAndHashCode/" data-id="ckkrzb8y3002vcv2ae2m1fiwx" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/04-commonAPIMethods" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/19/java/base/04-commonAPIMethods/" class="article-date">
  <time datetime="2018-05-19T08:11:45.000Z" itemprop="datePublished">2018-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/19/java/base/04-commonAPIMethods/">04 常用的API方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>1.Object类</li>
<li>2.String类</li>
<li>3.StringBuffer类与StringBuilder类</li>
<li>4.数组<ul>
<li>数组高级冒泡排序</li>
<li>数组高级选择排序</li>
<li>数组高级二分查找</li>
</ul>
</li>
<li>5.基本类型包装类</li>
<li>6.正则表达式</li>
<li>7.Pattern和Matcher类</li>
<li>8.Math类</li>
<li>9.Random类</li>
<li>10.System类</li>
<li>11.BigDecimal类</li>
<li>12.Date类</li>
<li>13.SimpleDateFormat类</li>
<li>14.Calendar类</li>
</ul>
<h4 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h4><ul>
<li><strong>1.1 Object有哪些公用方法？</strong><ul>
<li>a.方法equals测试的是两个对象是否相等</li>
<li>b.方法clone进行对象拷贝【问题：是浅拷贝还是深拷贝？】</li>
<li>c.方法getClass返回和当前对象相关的Class对象</li>
<li>d.方法notify,notifyall,wait都是用来对给定对象进行线程同步的</li>
</ul>
</li>
</ul>
<h4 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h4><ul>
<li><strong>2.1 String类的一些特性</strong><ul>
<li>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</li>
<li>字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</li>
<li>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.2 一旦被创建就不能改变</strong><ul>
<li>String s = new String(“hello”)和String s = “hello”;的区别</li>
<li>String的特点一旦被创建就不能改变【内容不能变，引用可以变】</li>
</ul>
</li>
</ul>
<ul>
<li><strong>问答题</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A:String的特点：一旦被创建就不能改变。</span><br><span class="line">B:案例演示   </span><br><span class="line">     a:如何理解这句话</span><br><span class="line">     String s = &quot;hello&quot; ;</span><br><span class="line">     s =  &quot;world&quot; + &quot;java&quot;; 问s的结果是多少?</span><br><span class="line"></span><br><span class="line">下面这条语句一共创建了多少个对象:String s = “a”+“b”+”c”; 分别都是什么？</span><br><span class="line">答案：5个对象</span><br><span class="line">分别是 &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;ab&quot; , &quot;abc&quot;</span><br><span class="line">因为字符串的特点是一旦被创建就不能被改变,所有在使用常量进行相加的时候,都是在创建新的字符串对象</span><br><span class="line">最后在把字符串&quot;abc&quot;这个常量值赋值给引用变量s</span><br><span class="line">这个答案是有歧义的， 根据现在的JIT,Q其实编译后的class 应该是String s = &quot;abc&quot;,题主问的这个问题只是想考大家关于java处理String的特点。</span><br></pre></td></tr></table></figure>
<ul>
<li>输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/4432347-6e12adf73739cfdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<h4 id="3-StringBuffer类与StringBuilder类"><a href="#3-StringBuffer类与StringBuilder类" class="headerlink" title="3.StringBuffer类与StringBuilder类"></a>3.StringBuffer类与StringBuilder类</h4><ul>
<li><strong>3.1 StringBuffer类概述</strong><ul>
<li>字符串缓冲区，StringBuffer是一个容器</li>
<li>我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。 而StringBuffer就可以解决这个问题</li>
<li>线程安全的可变的字符序列 , 安全对应的效率比较低</li>
</ul>
</li>
</ul>
<ul>
<li><strong>3.2 StringBuffer和String的区别</strong><ul>
<li>String是不可变的字符序列</li>
<li>StringBuffer 是可以的字符序列</li>
</ul>
</li>
</ul>
<ul>
<li><strong>3.3 StringBuffer和String的相互转换</strong></li>
<li>A:String – StringBuffer<ul>
<li>a:通过构造方法</li>
<li>b:通过append()方法</li>
</ul>
</li>
<li>B:StringBuffer – String<ul>
<li>a: 使用substring方法</li>
<li>b:通过构造方法</li>
<li>c:通过toString()方法</li>
</ul>
</li>
</ul>
<ul>
<li><strong>3.4 StringBuilder类</strong><ul>
<li>StringBuilder是线程不安全的，其他跟StringBuffer一样；StringBuffer和StringBuilder底层是 char[]数组实现的 </li>
</ul>
</li>
</ul>
<h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h4><ul>
<li><strong>4.1 数组高级冒泡排序原理图解</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-0ddf7d279e144929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
<li><p>冒泡排序原理</p>
<ul>
<li>相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处</li>
<li>冒泡排序代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 冒泡排序</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span> ; y &lt; arr.length - <span class="number">1</span>; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; arr.length - <span class="number">1</span> - y ; x++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[x] &gt; arr[x+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[x] ;</span><br><span class="line">                arr[x] = arr[x+<span class="number">1</span>] ;</span><br><span class="line">                arr[x+<span class="number">1</span>] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>4.2 数组高级选择排序原理图解</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-a498eca1c7f5b8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>选择排序原理<ul>
<li>从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处</li>
</ul>
</li>
<li>数组高级选择排序代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span> ; index &lt; arr.length - <span class="number">1</span> ; index++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = index + <span class="number">1</span> ; x &lt; arr.length ; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index] &gt; arr[x]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[index] ;</span><br><span class="line">                arr[index] = arr[x] ;</span><br><span class="line">                arr[x] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>4.3 数组高级二分查找原理图解</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-ce32a3a24ec74748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<ul>
<li>数组高级二分查找思想<ul>
<li>每一次都查中间的那个元素，比较大或者小就能减少一半的元素</li>
</ul>
</li>
<li>数组高级二分查找代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr , <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义三个变量</span></span><br><span class="line">    <span class="keyword">int</span> minIndex = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = arr.length - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(minIndex &lt;= maxIndex) &#123;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (minIndex + maxIndex) &gt;&gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="comment">// 比较</span></span><br><span class="line">        <span class="keyword">if</span>(arr[midIndex] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> midIndex ;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[midIndex] &gt; value) &#123;</span><br><span class="line">            maxIndex = midIndex - <span class="number">1</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[midIndex] &lt; value) &#123;</span><br><span class="line">            minIndex = midIndex + <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="5-基本类型包装类"><a href="#5-基本类型包装类" class="headerlink" title="5.基本类型包装类"></a>5.基本类型包装类</h4><ul>
<li><strong>5.1 为什么会有基本类型包装类</strong><ul>
<li>为了对基本数据类型进行更多的操作,更方便的操作,java就针对每一种基本数据类型提供了对应的类类型.</li>
<li>常用操作:<ul>
<li>常用的操作之一：用于基本数据类型与字符串之间的转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>5.2 基本类型和包装类的对应</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte           Byte</span><br><span class="line">short          Short</span><br><span class="line">int            Integer</span><br><span class="line">long           Long</span><br><span class="line">float          Float</span><br><span class="line">double         Double</span><br><span class="line">char           Character</span><br><span class="line">boolean        Boolean</span><br></pre></td></tr></table></figure>
<h4 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6.正则表达式"></a>6.正则表达式</h4><ul>
<li>正则表达式，不需要记忆，用的时候去查就可以呢<ul>
<li>是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</li>
<li>具体使用直接上网搜索<ul>
<li>例如，匹配手机号，邮箱，身份证号等等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-Pattern和Matcher类"><a href="#7-Pattern和Matcher类" class="headerlink" title="7.Pattern和Matcher类"></a>7.Pattern和Matcher类</h4><pre><code>* 正则的获取功能需要使用的类
</code></pre><h4 id="8-Math类"><a href="#8-Math类" class="headerlink" title="8.Math类"></a>8.Math类</h4><pre><code>* Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。
* 成员变量
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static final double E :         自然底数</span><br><span class="line">public static final double PI:        圆周率</span><br><span class="line">	* 成员方法</span><br><span class="line"></span><br><span class="line">public static int abs(int a)               取绝对值</span><br><span class="line">public static double ceil(double a)        向上取整</span><br><span class="line">public static double floor(double a)       向下取整</span><br><span class="line">public static int max(int a,int b)         获取最大值</span><br><span class="line">public static int min(int a, int b)        获取最小值</span><br><span class="line">public static double pow(double a,double b)获取a的b次幂</span><br><span class="line">public static double random()              获取随机数  返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</span><br><span class="line">public static int round(float a)           四舍五入</span><br><span class="line">public static double sqrt(double a)        获取正平方根</span><br></pre></td></tr></table></figure>
<h4 id="9-Random类"><a href="#9-Random类" class="headerlink" title="9.Random类"></a>9.Random类</h4><ul>
<li>随机类<ul>
<li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列</li>
<li>构造方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Random()             没有给定种子,使用的是默认的(当前系统的毫秒值)</span><br><span class="line">public Random(long seed) 给定一个long类型的种子,给定以后每一次生成的随机数是相同的</span><br><span class="line">public int nextInt()</span><br><span class="line">public int nextInt(int n)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="10-System类"><a href="#10-System类" class="headerlink" title="10.System类"></a>10.System类</h4><ul>
<li>系统级类<ul>
<li>System 类包含一些有用的类字段和方法。它不能被实例化。</li>
<li>系统级操作</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/05/19/java/base/04-commonAPIMethods/" data-id="ckkrzb8xh001xcv2amt8iyw4k" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/03-javaList" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/19/java/base/03-javaList/" class="article-date">
  <time datetime="2018-04-19T08:10:45.000Z" itemprop="datePublished">2018-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/19/java/base/03-javaList/">03 java泛型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li>1.泛型的概述</li>
<li>2.泛型的格式</li>
<li>3.泛型的好处</li>
<li>4.泛型的使用<ul>
<li>4.1 泛型类的概述及使用</li>
<li>4.2 泛型方法的概述和使用</li>
<li>4.3 泛型接口的概述和使用</li>
</ul>
</li>
<li>5.泛型高级之通配符<ul>
<li>5.1 &lt;? extends T&gt; 上界通配符</li>
<li>5.2 &lt;? super T&gt; 下界通配符</li>
<li>5.3 &lt;?&gt; 无界通配符</li>
</ul>
</li>
<li>6.可变参数的概述和使用</li>
<li>7.关于泛型拓展<ul>
<li>7.1 编译器类型检查</li>
<li>7.2 可读性和灵活性</li>
<li>7.3 泛型方法和泛型类的比较</li>
<li>7.4 泛型擦除案例</li>
</ul>
</li>
<li>8.泛型和反射</li>
</ul>
<h4 id="0-问题答疑"><a href="#0-问题答疑" class="headerlink" title="0.问题答疑"></a>0.问题答疑</h4><ul>
<li>1.什么是泛型，泛型主要有哪些应用场景？如何获取泛型的真实参数类型？具体是怎么操作的？</li>
<li>2.泛型通配符，上界或者下届包含自己吗？如何理解泛型擦除这个概念？泛型擦除会有哪些影响？</li>
<li>3.<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODc3NzQ4NQ==&amp;mid=2247483914&amp;idx=1&amp;sn=65b519f55fcb21a3db46e7044ef61c82&amp;chksm
=eb5099e8dc2710feb1bd4e2cf23d1e2d1f18df006eca49bc9ad2902df5a80d926859ea3a280e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Java 泛型边界与通配符实战踩坑面试题</a></li>
</ul>
<h3 id="1-泛型的概述"><a href="#1-泛型的概述" class="headerlink" title="1.泛型的概述"></a>1.泛型的概述</h3><h4 id="1-1-泛型由来"><a href="#1-1-泛型由来" class="headerlink" title="1.1 泛型由来"></a>1.1 泛型由来</h4><ul>
<li>我们的集合可以存储多种数据类型的元素,那么在存储的时候没有任何问题,但是在获取元素,并向下转型的时候,可能会存在一个错误,而这个错误就是ClassCastException . 很显然,集合的这种可以存储多种数据类型的元素的这个特点,不怎么友好 , 程序存在一些安全隐患,那么为了出来这种安全隐患,我们应该限定一个集合存储元素的数据类型,我们只让他存储统一中数据类型的元素,那么在做向下转型的是就不会存在这种安全隐患了. 怎么限定集合只能给我存储同一种数据类型的元素呢? 需要使用泛型。</li>
</ul>
<h4 id="1-2-基本概述"><a href="#1-2-基本概述" class="headerlink" title="1.2 基本概述"></a>1.2 基本概述</h4><ul>
<li>是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。</li>
<li>泛型的出现减少了很多强转的操作，同时避免了很多运行时的错误，在编译期完成检查类型转化</li>
</ul>
<h3 id="2-泛型的格式"><a href="#2-泛型的格式" class="headerlink" title="2.泛型的格式"></a>2.泛型的格式</h3><h4 id="2-1-泛型格式如下"><a href="#2-1-泛型格式如下" class="headerlink" title="2.1 泛型格式如下"></a>2.1 泛型格式如下</h4><ul>
<li>&lt;数据类型&gt;    这里的数据类型只能是引用数据类型</li>
<li>&lt;数据类型1 , 数据类型2 , ….&gt;</li>
</ul>
<h3 id="3-泛型的好处"><a href="#3-泛型的好处" class="headerlink" title="3.泛型的好处"></a>3.泛型的好处</h3><h4 id="3-1-好处"><a href="#3-1-好处" class="headerlink" title="3.1 好处"></a>3.1 好处</h4><ul>
<li>(1):把运行时期的问题提前到了编译期间</li>
<li>(2):避免了强制类型转换</li>
<li>(3):优化了程序设计，解决了黄色警告线</li>
</ul>
<h3 id="4-泛型的使用"><a href="#4-泛型的使用" class="headerlink" title="4.泛型的使用"></a>4.泛型的使用</h3><h4 id="4-1-泛型类的概述及使用"><a href="#4-1-泛型类的概述及使用" class="headerlink" title="4.1 泛型类的概述及使用"></a>4.1 泛型类的概述及使用</h4><ul>
<li>A:泛型类概述:        把泛型定义在类上</li>
<li>B:定义格式:           public class 类名&lt;泛型类型1,…&gt;</li>
<li>C:注意事项:           泛型类型必须是引用类型</li>
</ul>
<h4 id="4-2-泛型方法的概述和使用"><a href="#4-2-泛型方法的概述和使用" class="headerlink" title="4.2 泛型方法的概述和使用"></a>4.2 泛型方法的概述和使用</h4><ul>
<li>A:泛型方法概述:    把泛型定义在方法上</li>
<li>B:定义格式:           public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-3-泛型接口的概述和使用"><a href="#4-3-泛型接口的概述和使用" class="headerlink" title="4.3 泛型接口的概述和使用"></a>4.3 泛型接口的概述和使用</h4><ul>
<li>A:泛型接口概述:    把泛型定义在接口上</li>
<li>B:定义格式:        public interface 接口名&lt;泛型类型&gt;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型接口的定义格式:</span></span><br><span class="line"><span class="comment"> 修饰符  interface 接口名&lt;数据类型&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类是泛型类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(E t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Inter&lt;String&gt; inter = <span class="keyword">new</span> InterImpl&lt;String&gt;() ;</span><br><span class="line">inter.show(<span class="string">"hello"</span>) ;</span><br></pre></td></tr></table></figure>
<h3 id="5-泛型高级之通配符"><a href="#5-泛型高级之通配符" class="headerlink" title="5.泛型高级之通配符"></a>5.泛型高级之通配符</h3><h4 id="5-1-为什么要使用通配符"><a href="#5-1-为什么要使用通配符" class="headerlink" title="5.1 为什么要使用通配符"></a>5.1 为什么要使用通配符</h4><ul>
<li>通配符的设计存在一定的场景，例如在使用泛型后，首先声明了一个Animal的类，而后声明了一个继承Animal类的Cat类，显然Cat类是Animal类的子类，但是List<cat>却不是List<animal>的子类型，而在程序中往往需要表达这样的逻辑关系。为了解决这种类似的场景，在泛型的参数类型的基础上新增了通配符的用法。</animal></cat></li>
</ul>
<h4 id="5-1-lt-extends-T-gt-上界通配符"><a href="#5-1-lt-extends-T-gt-上界通配符" class="headerlink" title="5.1 &lt;? extends T&gt; 上界通配符"></a>5.1 &lt;? extends T&gt; 上界通配符</h4><ul>
<li>上界通配符顾名思义，&lt;? extends T&gt;表示的是类型的上界【 <strong>包含自身</strong>】，因此通配的参数化类型可能是T或T的子类。正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List<animal>和List<cat>是List&lt;? extends Animal&gt;的子类型。</cat></animal></li>
</ul>
<h4 id="5-2-lt-super-T-gt-下界通配符"><a href="#5-2-lt-super-T-gt-下界通配符" class="headerlink" title="5.2 &lt;? super T&gt; 下界通配符"></a>5.2 &lt;? super T&gt; 下界通配符</h4><ul>
<li>下界通配符&lt;? super T&gt;表示的是参数化类型是T的超类型（<strong>包含自身</strong>），层层至上，直至Object，编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。</li>
</ul>
<h4 id="5-3-lt-gt-无界通配符"><a href="#5-3-lt-gt-无界通配符" class="headerlink" title="5.3 &lt;?&gt; 无界通配符"></a>5.3 &lt;?&gt; 无界通配符</h4><ul>
<li>任意类型，如果没有明确，那么就是Object以及任意的Java类了</li>
<li>无界通配符用&lt;?&gt;表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List<object>和List<null>的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）。</null></object></li>
</ul>
<h3 id="6-可变参数的概述和使用"><a href="#6-可变参数的概述和使用" class="headerlink" title="6.可变参数的概述和使用"></a>6.可变参数的概述和使用</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><ul>
<li>A:可变参数概述:          定义方法的时候不知道该定义多少个参数</li>
<li>B:格式:                       修饰符 返回值类型 方法名(数据类型…  变量名){}</li>
<li>C:注意事项：<ul>
<li>a:    这里的变量其实是一个数组</li>
<li>b:    如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个</li>
</ul>
</li>
</ul>
<h3 id="7-关于泛型拓展"><a href="#7-关于泛型拓展" class="headerlink" title="7.关于泛型拓展"></a>7.关于泛型拓展</h3><h4 id="7-1-编译器类型检查"><a href="#7-1-编译器类型检查" class="headerlink" title="7.1 编译器类型检查"></a>7.1 编译器类型检查</h4><pre><code>* A.编译器类型检查
</code></pre><p><img src="/images/4432347-b5e6e5cfa996fc1f.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 在引入泛型之后，通过将代码中的“public class Box”更改为“public class Box&lt;T&gt;”来创建泛型类型的声明，而这个声明的背后实质上是引入了可以在类中任何地方使用的类型变量T。如实例4中所示：可以看到，除了新增的泛型类型声明&lt;T&gt;外，所有在原来代码中出现的Object都被类型变量T所替换。</span><br><span class="line">* 乍一看类型变量这个词，感觉有点晦涩难懂，但其实如果仔细思量一番会发现它其实并不难理解，上面的实例4可以理解为“在使用泛型时，可以将类型参数T传递给Box类型本身”，结合Oracle给出的官方定义“泛型的本质是类型参数化”会有更深的理解。</span><br><span class="line">* 在实例5中，在对象声明和初始化的时候，都指定了类型参数T，在场景一种，T为String；在场景二中，T为Integer。这样，在场景二中向IntegerBox中传入String类型的数据“aaaaa”时，程序会报错。实例6中的泛型集合对象的操作也与之类似，在声明了一个List&lt;String&gt;的boxes对象之后，如果向boxes中传入Integer对象11111，程序会报错。</span><br><span class="line">* 可以看到，通过对于泛型的使用，之前的多业务场景中的问题都得到了解决，因为现在在编译阶段就可以解决之前类型不匹配的问题，而不用等到运行时才暴露问题，只要合理使用泛型，就能在很大程度上规避此类风险。对于泛型的使用，这种参数化类型的作用表面上看是声明，背后其实是约定。</span><br></pre></td></tr></table></figure>
<h4 id="7-2-可读性和灵活性"><a href="#7-2-可读性和灵活性" class="headerlink" title="7.2 可读性和灵活性"></a>7.2 可读性和灵活性</h4><ul>
<li>泛型除了能进行编译器类型检查和规避类型强制转换外，还能有效地提高代码的可读性。如果不使用泛型，当一个不清楚业务场景的人在对集合进行操作时，无法知道list中存储的是什么类型的对象，如果使用了泛型，就能够通过其类型参数判断出当前的业务场景，也增加了代码的可读性，同时也可以大胆地在抽象继承的基础上进行开发了。</li>
<li>泛型使用上的灵活性体现在很多方面，因为它本身实质上就是对于继承在使用上的一种增强。因为泛型在具体工作时，当编译器在编译源码的时候，首先要进行泛型类型参数的检查，检查出类型不匹配等问题，然后进行类型擦除并同时在类型参数出现的位置插入强制转换指令，从而实现泛型。</li>
</ul>
<h4 id="7-3-泛型方法和泛型类的比较"><a href="#7-3-泛型方法和泛型类的比较" class="headerlink" title="7.3 泛型方法和泛型类的比较"></a>7.3 泛型方法和泛型类的比较</h4><ul>
<li>例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;()</span>&#123;</span><br><span class="line">    <span class="comment">//泛型类的成员方法，该T受A后面的T的限制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">memberFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//泛型方法，这里的T和和类A的T是不同的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">genericFunc</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Integer i = A&lt;String&gt;().findByUserName("s");</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        Set&lt;Integer&gt; set=  A&lt;String&gt;().findByConditions(<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里<code>Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);</code>会编译报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(35, 61) java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer`</span><br></pre></td></tr></table></figure>
</li>
<li><p>由这个例子可知，泛型方法的T和和类A的T是不同的。</p>
</li>
</ul>
<h4 id="7-4-泛型擦除案例"><a href="#7-4-泛型擦除案例" class="headerlink" title="7.4 泛型擦除案例"></a>7.4 泛型擦除案例</h4><ul>
<li><p>泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GenericTest().testType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; collection1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; collection2= <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        System.out.println(collection1.getClass()==collection2.getClass());</span><br><span class="line">        <span class="comment">//两者class类型一样,即字节码一致</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(collection2.getClass().getName());</span><br><span class="line">        <span class="comment">//class均为java.util.ArrayList,并无实际类型参数信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">java.util.ArrayList</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>使用反射可跳过编译器，往某个泛型集合加入其它类型数据。</em></p>
<ul>
<li>只有引用类型才能作为泛型方法的实际参数</li>
<li>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        swap(<span class="keyword">new</span> String[]&#123;<span class="string">"111"</span>,<span class="string">"222"</span>&#125;,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//编译通过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//swap(new int[]&#123;1,2&#125;,0,1);</span></span><br><span class="line">        <span class="comment">//编译不通过,因为int不是引用类型</span></span><br><span class="line">        </span><br><span class="line">        swap(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//编译通过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*交换数组a 的第i个和第j个元素*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T[]a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        T temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>但注意基本类型<strong>有时</strong>可以作为实参，因为有<strong>自动装箱</strong>和<strong>拆箱</strong>。</p>
<ul>
<li><p>例子(编译通过了)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> GenericTest().testType();</span><br><span class="line">        <span class="keyword">int</span> a = biggerOne(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//int 和 double,取交为Number</span></span><br><span class="line">        Number b = biggerOne(<span class="number">3</span>,<span class="number">5.5</span>);</span><br><span class="line">        <span class="comment">//String和int 取交为Object</span></span><br><span class="line">        Object c = biggerOne(<span class="string">"1"</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从x,y中返回y</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">biggerOne</span><span class="params">(T x,T y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时，该例还表明，<strong>当实参不一致时，T取交集，即第一个共同的父类。</strong></p>
</li>
<li><p>另外，如果用<code>Number b = biggerOne(3,5.5);</code>改为<code>String c = biggerOne(3,5.5);</code>则编译报错:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:(17, 29) java: 不兼容的类型: 推断类型不符合上限</span><br><span class="line">    推断: java.lang.Number&amp;java.lang.Comparable&lt;? extends java.lang.Number&amp;java.lang.Comparable&lt;?&gt;&gt;</span><br><span class="line">    上限: java.lang.String,java.lang.Object</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="8-泛型和反射"><a href="#8-泛型和反射" class="headerlink" title="8.泛型和反射"></a>8.泛型和反射</h3><h4 id="通过反射获得泛型的实际类型参数"><a href="#通过反射获得泛型的实际类型参数" class="headerlink" title="通过反射获得泛型的实际类型参数"></a>通过反射获得泛型的实际类型参数</h4><ul>
<li>把泛型变量当成方法的参数，利用Method类的getGenericParameterTypes方法来获取泛型的实际类型参数</li>
<li><p>例子：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        getParamType();</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">/*利用反射获取方法参数的实际参数类型*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getParamType</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException</span>&#123;</span><br><span class="line">        Method method = GenericTest.class.getMethod(<span class="string">"applyMap"</span>,Map.class);</span><br><span class="line">        <span class="comment">//获取方法的泛型参数的类型</span></span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        System.out.println(types[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//参数化的类型</span></span><br><span class="line">        ParameterizedType pType  = (ParameterizedType)types[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//原始类型</span></span><br><span class="line">        System.out.println(pType.getRawType());</span><br><span class="line">        <span class="comment">//实际类型参数</span></span><br><span class="line">        System.out.println(pType.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(pType.getActualTypeArguments()[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*供测试参数类型的方法*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyMap</span><span class="params">(Map&lt;Integer,String&gt; map)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Map&lt;java.lang.Integer, java.lang.String&gt;</span><br><span class="line">interface java.util.Map</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.String</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/04/19/java/base/03-javaList/" data-id="ckkrzb8y1002rcv2amnc81m17" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/02-javaBase" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/19/java/base/02-javaBase/" class="article-date">
  <time datetime="2018-03-19T08:09:45.000Z" itemprop="datePublished">2018-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/19/java/base/02-javaBase/">02 java基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>主要介绍Java语言概述、Java标识符规则、常量和变量、进制、Java数据类型、字符编码、运算符、Java基本语句结构、方法、数组、内存分配等。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>注意：红色字体为未答出的知识点</li>
<li>0.Java语言概述</li>
<li>1.Java标识符规则【规则，注意事项，命名规范】</li>
<li>2.常量和变量【区别，常量种类】</li>
<li>3.进制【种类，转换，补码反码】</li>
<li>4.Java数据类型【种类，转换规则，注意要点】</li>
<li>5.字符编码【种类】</li>
<li>6.运算符【种类，区别】</li>
<li>7.Java基本语句结构【种类，区别说明】</li>
<li>8.方法【定义，格式】</li>
<li>9.数组【一维数组，二维数组】</li>
<li>10.内存分配以及栈和堆的</li>
<li>11.使用switch和if-else区别</li>
</ul>
<h4 id="0-Java语言概述"><a href="#0-Java语言概述" class="headerlink" title="0.Java语言概述"></a>0.Java语言概述</h4><ul>
<li><strong>0.1 jdk工具部分exe解释</strong><ul>
<li>jar.exe       jar包</li>
<li>javadoc.exe   文档生成器</li>
<li>Java.exe      解释器</li>
<li>Javac.exe     编辑器</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>0.2 开发与运行Java程序需经过哪些过程？</strong></p>
<ul>
<li>用工具编辑源程序，也就是写代码，保存</li>
<li>用Java编辑器工具javac.exe编译源程序文件，生成字节码.class文件</li>
<li>用Java解释器工具Java.exe解释运行生成.class文件</li>
</ul>
</li>
<li><p><strong>0.3 Java是如何实现跨平台的？</strong></p>
<ul>
<li>如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">跨平台是怎样实现的呢？这就要谈及Java虚拟机（Java Virtual Machine，简称 JVM）。</span><br><span class="line"></span><br><span class="line">JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。</span><br><span class="line"></span><br><span class="line">Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</span><br><span class="line"></span><br><span class="line">而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。</span><br><span class="line"></span><br><span class="line">JVM是一个”桥梁“，是一个”中间件“，是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java程序的目的。</span><br><span class="line"></span><br><span class="line">注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</span><br><span class="line"></span><br><span class="line">所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。</span><br><span class="line"></span><br><span class="line">注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="1-Java标识符规则"><a href="#1-Java标识符规则" class="headerlink" title="1.Java标识符规则"></a>1.Java标识符规则</h4><ul>
<li><strong>1.1 组成规则</strong><ul>
<li>英文大小写字母</li>
<li>数字字符</li>
<li>$或_</li>
</ul>
</li>
<li><strong>1.2 注意事项</strong><ul>
<li>不能以数字开头</li>
<li>不能是Java中的关键字</li>
<li>区分大小写</li>
<li>不能有空格</li>
</ul>
</li>
<li><strong>1.3 命名规范【必须见名知意】</strong><ul>
<li>下划线式命名：my_name</li>
<li>驼峰式命名：myName</li>
<li>类，接口命名：必须是大写字母开头，比如PersonActivity</li>
<li>方法，变量【字符串】命名：getData()，otherName</li>
<li>常量命名：一般全是大写，比如MAX_VALUE</li>
</ul>
</li>
</ul>
<h4 id="2-常量和变量"><a href="#2-常量和变量" class="headerlink" title="2.常量和变量"></a>2.常量和变量</h4><ul>
<li><strong>2.1 什么是常量和变量</strong><ul>
<li>其值不可以改变的称之为常量</li>
<li>其值会发生变化的称之为变量</li>
</ul>
</li>
<li><strong>2.2 常量有哪些</strong><ul>
<li>字符串常量     用双引号包括的     “hello world”</li>
<li>整型常量         所有的整数     199</li>
<li>小数常量         所有的小数     4.50</li>
<li>字符常量         用单引号包括的     ‘a’</li>
<li>布尔常量         true和false    </li>
<li>空常量            null</li>
</ul>
</li>
<li><strong>2.3 变量</strong><ul>
<li>用来描述值可以变化的量，比如室外温度，App活跃用户量等</li>
</ul>
</li>
</ul>
<h4 id="3-进制"><a href="#3-进制" class="headerlink" title="3.进制"></a>3.进制</h4><ul>
<li><strong>3.1 进制有哪些</strong></li>
<li>二进制<ul>
<li>0和1     前缀0B或者0b       比如：0B1001      转为十进制是9</li>
</ul>
</li>
<li>八进制<ul>
<li>0-7       前缀0       比如：0103       </li>
</ul>
</li>
<li>十进制【我们常用的】<ul>
<li>0-9       没有前缀</li>
</ul>
</li>
<li>十六进制<ul>
<li>0-9 和 A-F     前缀0x或者0X          比如：0x123</li>
</ul>
</li>
<li>进制转化<ul>
<li>任何进制转化为十进制公式：系数 * 底数 ^ 指数</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0b1010 = 1 * 2^3 + 0 *2^2 + 1*2^1 + 0*2^0</span><br><span class="line">       = 8 + 0 + 2 + 0</span><br><span class="line">       = 10</span><br><span class="line"></span><br><span class="line">0123  = 1*8^2 + 2*8^1 + 3*8^0</span><br><span class="line">      = 64 + 16 + 3</span><br><span class="line">      = 83</span><br><span class="line"></span><br><span class="line">0x123 = 1*16^2 + 2*16^1 + 3*16^0</span><br><span class="line">      = 256 + 32 + 3</span><br><span class="line">      = 291</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.2 补码</strong><ul>
<li>正数的补码和原码相同</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">原码：0000 0101</span><br><span class="line">补码：0000 0101</span><br><span class="line">	* 负数的补码是它的反码加1</span><br><span class="line"></span><br><span class="line">-5：</span><br><span class="line">原码：1000 0101</span><br><span class="line">反码：1111 1010</span><br><span class="line">    +         1</span><br><span class="line">------------------</span><br><span class="line">补码  1111 1011</span><br></pre></td></tr></table></figure>
<h4 id="4-Java数据类型"><a href="#4-Java数据类型" class="headerlink" title="4.Java数据类型"></a>4.Java数据类型</h4><ul>
<li><strong>4.1 数据类型有哪些</strong></li>
<li>byte类型<ul>
<li>1个字节，8位【-128到127之间】</li>
</ul>
</li>
<li>short类型<ul>
<li>2个字节，16位【-2^15 到 2^15 -1】</li>
</ul>
</li>
<li>int类型<ul>
<li>4个字节，32位【-2^31 到 2^31 -1】</li>
</ul>
</li>
<li>float类型【浮点型】<ul>
<li>4个字节，32位</li>
</ul>
</li>
<li>double类型【浮点型】<ul>
<li>8个字节，64位</li>
</ul>
</li>
<li>long类型<ul>
<li>8个字节，64位【-2^63  到 2^63 -1】</li>
</ul>
</li>
<li>char类型<ul>
<li>2个字节，16位【1个汉字刚好2个字节】</li>
</ul>
</li>
<li>boolean类型<ul>
<li>1个字节，true和false</li>
</ul>
</li>
</ul>
<ul>
<li><strong>4.2 数据的转换</strong></li>
<li>默认转换<ul>
<li>1：byte,short,char—int—long—float—double</li>
<li>2：byte,short,char相互之间补转换，他们参与运算首先转换为int类型</li>
</ul>
</li>
<li>强制转换<ul>
<li>格式: 目标类型 变量名 = (目标类型)值或变量名</li>
<li>int a = (int) 15.7f;</li>
</ul>
</li>
<li>注意要点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!!!!!!注意!!!!!!!!</span><br><span class="line">1:在java中，任何一个整数默认为 int 类型 (1)</span><br><span class="line">2:在java种，任何一个小数，默认为 double 类型( 1.0)</span><br><span class="line">3:123L 或者 1231 编译器会将该数当成long类型</span><br><span class="line">4:12.345f 或者12.345F 编译器会将该数当成float类型</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-字符编码"><a href="#5-字符编码" class="headerlink" title="5.字符编码"></a>5.字符编码</h4><ul>
<li>常见的字符编码<ul>
<li>ASCII码</li>
<li>GBK码</li>
<li>Unicode码【占2个字节】</li>
</ul>
</li>
</ul>
<h4 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h4><ul>
<li><strong>6.1 运算符有哪些？</strong><ul>
<li>算术运算符</li>
<li>赋值运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>三目运算符</li>
<li>特殊运算符：位运算符</li>
</ul>
</li>
<li><strong>6.2 算术运算符</strong><ul>
<li><ul>
<li>，- ， * ， / ， %【取余】 ， ++【自加】， –【自减】</li>
</ul>
</li>
</ul>
</li>
<li><strong>6.3 赋值运算符</strong><ul>
<li>= ， += ， -= ， *= ， /= ， %= </li>
</ul>
</li>
<li><strong>6.4 关系运算符</strong><ul>
<li>== ， &gt; , &lt; , &gt;= , &lt;= , !=</li>
</ul>
</li>
<li><strong>6.5 逻辑运算符</strong><ul>
<li>&amp; ，^ ，| ，&amp;&amp; ，|| ，！ ， ^</li>
</ul>
</li>
<li><strong>6.6 三目运算符【Android中用的很多】</strong><ul>
<li>a == b ？ c ： d</li>
<li>格式：(条件表达式)？表达式1：表达式2</li>
</ul>
</li>
<li><strong>6.7 位运算符</strong><ul>
<li>&amp; , |   ,  ^ ,  ~  ,  &lt;&lt;  ,  &gt;&gt;  ,  &gt;&gt;&gt;</li>
</ul>
</li>
</ul>
<h4 id="7-Java基本语句结构"><a href="#7-Java基本语句结构" class="headerlink" title="7.Java基本语句结构"></a>7.Java基本语句结构</h4><ul>
<li><strong>7.1 语句结构种类</strong><ul>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
</ul>
</li>
<li><strong>7.2 顺序结构</strong><ul>
<li>从上到下依次执行</li>
</ul>
</li>
<li><strong>7.3 选择结构【可以嵌套】</strong><ul>
<li>if  ，  if  else  ， if  else if …… else</li>
<li>switch case【支持byte，short，char，int，String】</li>
</ul>
</li>
<li><strong>7.4 循环结构</strong></li>
<li><p>for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(初始化语句;判断条件语句;控制条件语句) &#123;</span><br><span class="line">         循环体语句;</span><br><span class="line">&#125;</span><br><span class="line">第一步：先执行初始化语句，只执行一次</span><br><span class="line">第二步：执行判断条件语句</span><br><span class="line">第三部：执行循环体语句</span><br><span class="line">第四步：执行控制条件语句，然后再执行循环体语句【循环】</span><br></pre></td></tr></table></figure>
</li>
<li><p>while</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">while(判断条件语句) &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">    控制条件语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>do while</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">         循环体语句;</span><br><span class="line">&#125;while((判断条件语句);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-Java方法"><a href="#8-Java方法" class="headerlink" title="8.Java方法"></a>8.Java方法</h4><ul>
<li><strong>8.1 定义</strong></li>
<li>方法就是完成特定功能的代码块<ul>
<li>1：系统方法，只需要会使用，不需要知道内部的结构</li>
<li>2：自定义方法：方法的内部实现需要我们来写</li>
<li>3：方法内部不能再嵌套方法</li>
</ul>
</li>
</ul>
<ul>
<li><strong>8.2 格式</strong></li>
<li><p>方法格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符   返回值类型   方法名(参数类型 参数 , ……)&#123;</span><br><span class="line">     函数体</span><br><span class="line">     return 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰符: public static或直接是public或是其它private</p>
</li>
<li>返回类型:所有的数据类型（基本类型：int ,char ,float, long, 引用类型:String）</li>
<li>方法名：1:见名知意 2: getMax</li>
<li>参数类型:所有的数据类型 ，如果一个方法没有返回值，则返回值类型为void</li>
<li>参数名:变量名</li>
<li>返回值：就是要返回的结果（这个结果必须和返回类型一致）</li>
</ul>
<h4 id="9-数组"><a href="#9-数组" class="headerlink" title="9.数组"></a>9.数组</h4><ul>
<li><strong>9.1 数组概念</strong><ul>
<li>数组是一个容器，可以存储多个变量，这些变量数据类型要一致</li>
<li>数组既可以存储基本数据类型，也可以存储引用数据类型</li>
</ul>
</li>
</ul>
<ul>
<li><strong>9.2 一维数组</strong></li>
<li><p>数组定义格式</p>
<ul>
<li>格式1：数据类型【】 数组名</li>
<li>格式2：数据类型   数组名【】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] a；     定义了一个int类型的数组a；</span><br><span class="line">int a[];    定义了一个int类型的a数组；</span><br><span class="line">推荐使用第一种定义方式。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组的初始化</p>
<ul>
<li>Java中的数组必须先初始化,然后才能使用。</li>
<li>所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。</li>
</ul>
</li>
</ul>
<ul>
<li>初始化分类：<ul>
<li>a:动态初始化:   只指定长度，由系统给出初始化值</li>
<li>b:静态初始化:    给出初始化值，由系统决定长度</li>
<li>注意事项：这两种方式，只能使用一种，不能进行动静结合   </li>
</ul>
</li>
</ul>
<ul>
<li><strong>9.3 二维数组</strong></li>
<li>数组定义格式<ul>
<li>数据类型[][] 变量名 = new 数据类型[m][n];</li>
<li>m表示这个二维数组有多少个一维数组</li>
<li>n表示每一个一维数组的元素个数</li>
</ul>
</li>
</ul>
<ul>
<li>举例:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr = new int[3][2];</span><br><span class="line">定义了一个二维数组arr</span><br><span class="line">这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]</span><br><span class="line">每个一维数组有2个元素，可以通过arr[m][n]来获取,表示获取第m+1个一维数组的第n+1个元素</span><br></pre></td></tr></table></figure>
<h4 id="10-Java的内存分配以及栈和堆的区别"><a href="#10-Java的内存分配以及栈和堆的区别" class="headerlink" title="10.Java的内存分配以及栈和堆的区别"></a>10.Java的内存分配以及栈和堆的区别</h4><ul>
<li><strong>10.1 先了解几个概念</strong><ul>
<li>栈</li>
<li>堆</li>
<li>方法区</li>
<li>本地方法去</li>
<li>寄存器</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A:栈: 存放的是局部变量</span><br><span class="line">局部变量：在方法定义或者方法声明上的变量都是局部变量。</span><br><span class="line">B:堆: 存放的是所有new出来的东西</span><br><span class="line">特点：</span><br><span class="line">    a: 每一个new出来的东西都会为其分配一个地制值。</span><br><span class="line">    b: 每一个变量都有一个默认的值</span><br><span class="line">        byte，short，int，long  -- 0</span><br><span class="line">        float，double            -- 0.0</span><br><span class="line">        char                    -- &apos;\u0000&apos;</span><br><span class="line">        boolean                -- false</span><br><span class="line">        引用数据类型               -- null       </span><br><span class="line">    c: 使用完毕就变成了垃圾，等待垃圾回收器对其回收</span><br><span class="line">C:方法区:(面向对象部分讲解)</span><br><span class="line">D:本地方法区:(和系统相关)</span><br><span class="line">E:寄存器:(cpu使用)</span><br></pre></td></tr></table></figure>
<h4 id="11-使用switch和if-else区别"><a href="#11-使用switch和if-else区别" class="headerlink" title="11.使用switch和if-else区别"></a>11.使用switch和if-else区别</h4><ul>
<li><strong>11.1 switch语句特点</strong></li>
<li>使用switch语句时，要注意表达式必须是符合byte，char，short，int或枚举类型的表达式，而不能使用浮点类型或long类型。</li>
<li>switch语句将表达式的值依次与每个case子语句中的常量值相比较。如果匹配成功，则执行该case语句中的语句，直到遇到break语句为止。</li>
<li><p>default语句是可选的，当表达式的值与任何一个case语句都不匹配时，就执行default后的语句。</p>
</li>
<li><p><strong>11.2 switch语句与if-else比较</strong></p>
</li>
<li>if-else只是单纯地一个接一个比较；if…else每个条件都计算一遍；</li>
<li>使用了Binary，Tree算法；绝大部分情况下switch会快一点，除非是if-else的第一个条件就为true。编译器编译switch与编译if…else…不同。不管有多少case，都直接跳转，不需逐个比较查询；switch只计算一次值，然后都是test , jmp……有很多else if的时候，用switch case比较清晰</li>
<li>switch…case与if…else，if的根本区别在于，switch…case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch…case不用像if…else那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/03/19/java/base/02-javaBase/" data-id="ckkrzb8y0002qcv2addvd9181" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-java/base/01-javaKeys" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/19/java/base/01-javaKeys/" class="article-date">
  <time datetime="2018-02-19T08:08:45.000Z" itemprop="datePublished">2018-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/19/java/base/01-javaKeys/">01 java关键字</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>关键字指的就是电脑语言中事先定义好，有其独特意义的标识符，专门提供给电脑语言识别的词语，所以它不能作为变量名、方法名、类名、包名或参数名等等.</p>
<h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li>1.常用的关键字</li>
<li>2.关键字的作用说明</li>
<li><p>3.重要关键字的说明</p>
<h3 id="1-常用关键字"><a href="#1-常用关键字" class="headerlink" title="1.常用关键字"></a>1.常用关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">用于定义数据类型的关键字</span><br><span class="line">class interface byte short int long float double char boolean void               </span><br><span class="line">用于定义数据类型值的关键字</span><br><span class="line">true false null       </span><br><span class="line">用于定义流程控制的关键字</span><br><span class="line">if else switch case default while do for break continue return           </span><br><span class="line">用于定义访问权限修饰符的关键字</span><br><span class="line">private protected public       </span><br><span class="line">用于定义类，函数，变量修饰符的关键字</span><br><span class="line">abstract final static synchronized   </span><br><span class="line">用于定义类与类之间关系的关键字</span><br><span class="line">extends implements           </span><br><span class="line">用于定义建立实例及引用实例，判断实例的关键字</span><br><span class="line">new this super instanceof   </span><br><span class="line">用于异常处理的关键字</span><br><span class="line">try catch finally throw    throws</span><br><span class="line">用于包的关键字</span><br><span class="line">package import           </span><br><span class="line">其他修饰符关键字</span><br><span class="line">native strictfp transient volatile assert</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果有未被收录的，可以提醒！</p>
</blockquote>
</li>
</ul>
<h3 id="2-关键字的作用说明"><a href="#2-关键字的作用说明" class="headerlink" title="2.关键字的作用说明"></a>2.关键字的作用说明</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">break           用在 switch 或者循环语句中，表示中断结束的意思，跳出循环直接可以结束该语句</span><br><span class="line">continue        用在循环语句中，表示中断结束的意思，不过跟 break 有区别，它是退出本次循环后继续执行下一次循环           </span><br><span class="line">return          常用功能是结束一个方法（退出一个方法），跳转到上层调用的方法</span><br><span class="line">interface       接口的意思，用来定义接口。</span><br><span class="line">static          静态修饰符，被修饰后成员被该类所有的对象所共有。也可以通过类名调用</span><br><span class="line">private         权限修饰符，可以修饰成员变量和成员方法，被修饰的成员只能在本类中被访问        隐藏具体实现细节，提供对外公共访问方法，提高安全性</span><br><span class="line">this            当成员变量和局部变量名称一样时，需要用 this 修饰，谁调用这个方法,那么该方法的内部的this就代表谁，如果不适用 this ，那么局部变量隐藏了成员变量</span><br><span class="line">super           代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)</span><br><span class="line">final           由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.这对这种情况java就给我们提供了一个关键字: final</span><br><span class="line">                可以修饰类，变量，成员方法。被修饰类不能被继承；被修饰的方法不能被重写；被修饰的变量不能被重新赋值,因为这个量其实是一个常量。</span><br><span class="line">                修饰基本数据类型    指的是值不能被改变；修饰引用数据类型    指的是地址值不能被改变</span><br><span class="line">finally         被finally控制的语句体一定会执行；特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))</span><br><span class="line">                finally的作用:    用于释放资源，在IO流操作和数据库操作中会见到</span><br><span class="line">abstract        抽象的意思，用来修饰抽象类与抽象方法。abstract 不能和哪些关键字共存?</span><br><span class="line">                 private    冲突        被private修饰的方法不能被子类继承,就不能被重写,而我们的抽象方法还需要被子类重写</span><br><span class="line">                 final      冲突        被final修饰的方法,不能被子类重写 , ,而我们的抽象方法还需要被子类重写</span><br><span class="line">                 static     无意义    因为被static修饰的方法可以通过类名直接访问,但是我们的抽象方法没有方法体,所以这样访问没有意思</span><br><span class="line">extends         继承的意思，通过它可以类与类之间产生继承关系。</span><br><span class="line">implements      实现的意思，通过它可以让类与接口之间产生实现关系。</span><br><span class="line">instanceof      测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据</span><br></pre></td></tr></table></figure>
<h3 id="3-重要关键字说明"><a href="#3-重要关键字说明" class="headerlink" title="3.重要关键字说明"></a>3.重要关键字说明</h3><h4 id="3-1-instanceof"><a href="#3-1-instanceof" class="headerlink" title="3.1 instanceof"></a>3.1 instanceof</h4><ul>
<li>instanceof是Java的一个二元操作符，和==，&gt;，&lt;是同一类东西。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据。</li>
</ul>
<h4 id="3-2-final-finally-finalize有什么不同？"><a href="#3-2-final-finally-finalize有什么不同？" class="headerlink" title="3.2 final,finally,finalize有什么不同？"></a>3.2 final,finally,finalize有什么不同？</h4><ul>
<li><strong>final可以修饰类，方法，变量</strong><ul>
<li>final修饰类代表类不可以继承拓展</li>
<li>final修饰变量表示变量不可以修改</li>
<li>final修饰方法表示方法不可以被重写</li>
</ul>
</li>
<li><strong>finally则是Java保证重点代码一定要被执行的一种机制</strong><ul>
<li>可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC连接、保证 unlock 锁等动作。</li>
</ul>
</li>
<li><strong>finalize 是基础类 java.lang.Object的一个方法</strong><ul>
<li>它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9开始被标记为 deprecated。</li>
</ul>
</li>
<li><strong>final 关键字深入理解</strong><ul>
<li>可以将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的。</li>
<li>如果你关注过Java核心类库的定义或源码，有没有发现java.lang 包下面的很多类，相当一部分都被声明成为final class？在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。</li>
<li>使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final。</li>
<li>final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li>
</ul>
</li>
</ul>
<h4 id="3-3-static"><a href="#3-3-static" class="headerlink" title="3.3 static"></a>3.3 static</h4><ul>
<li>可以用来修饰：成员变量，成员方法，代码块，内部类等。具体如下所示<ul>
<li><strong>修饰成员变量和成员方法</strong> <ul>
<li>被static修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。</li>
<li>被static声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。</li>
</ul>
</li>
<li><strong>静态代码块</strong> <ul>
<li>静态代码块定义在类中方法外,静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)</li>
<li>该类不管创建多少对象，静态代码块只执行一次.</li>
</ul>
</li>
<li><strong>静态内部类（static修饰类的话只能修饰内部类）</strong> <ul>
<li>非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：1.它的创建是不需要依赖外围类的创建。2.它不能使用任何外围类的非static成员变量和方法。</li>
</ul>
</li>
<li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性)</strong><ul>
<li>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2018/02/19/java/base/01-javaKeys/" data-id="ckkrzb8xf001tcv2a6jcsflx9" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/02/05/送你一朵小红花/">送你一朵小红花</a>
          </li>
        
          <li>
            <a href="/2020/03/01/base/vim学习/">vim学习</a>
          </li>
        
          <li>
            <a href="/2020/02/23/前端往事/">前端往事</a>
          </li>
        
          <li>
            <a href="/2020/02/10/散文/鲁迅名句摘要/">鲁迅名句摘要</a>
          </li>
        
          <li>
            <a href="/2019/07/18/network/c10k问题/">C10K问题由来</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 popc&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;cc5853235@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>