<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>常见的数据结构 | 飞翔的企鹅</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录结构 1.常用数据有哪些 2.数据的说明 3.集合数据结构介绍 4.集合{List，Set，Map}的特点 5.Queue队列">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="常见的数据结构">
<meta property="og:url" content="https://blog.okjvm.com/2017/11/20/java/dataStructure/01.baseDataStructure/index.html">
<meta property="og:site_name" content="飞翔的企鹅">
<meta property="og:description" content="目录结构 1.常用数据有哪些 2.数据的说明 3.集合数据结构介绍 4.集合{List，Set，Map}的特点 5.Queue队列">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4432347-84cb744b434c0bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4432347-95c1a4cac03f1510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4432347-99e078e9f90f1366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4432347-44f75cb827c7ce06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-03-17T12:44:07.747Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常见的数据结构">
<meta name="twitter:description" content="目录结构 1.常用数据有哪些 2.数据的说明 3.集合数据结构介绍 4.集合{List，Set，Map}的特点 5.Queue队列">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/4432347-84cb744b434c0bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="飞翔的企鹅" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.okjvm.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">飞翔的企鹅</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎访问</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java/dataStructure/01.baseDataStructure" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/20/java/dataStructure/01.baseDataStructure/" class="article-date">
  <time datetime="2017-11-20T10:00:54.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      常见的数据结构
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>1.常用数据有哪些</li>
<li>2.数据的说明</li>
<li>3.集合数据结构介绍</li>
<li>4.集合{List，Set，Map}的特点</li>
<li>5.Queue队列</li>
</ul>
<a id="more"></a>
<h4 id="1-常用数据有哪些？"><a href="#1-常用数据有哪些？" class="headerlink" title="1.常用数据有哪些？"></a>1.常用数据有哪些？</h4><ul>
<li><strong>1.1 如下图所示：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-84cb744b434c0bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/4432347-95c1a4cac03f1510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<ul>
<li><strong>1.2 常见的集合数据</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-99e078e9f90f1366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<h4 id="2-数据的说明"><a href="#2-数据的说明" class="headerlink" title="2.数据的说明"></a>2.数据的说明</h4><ul>
<li><strong>2.1 数组</strong></li>
<li><img src="https://upload-images.jianshu.io/upload_images/4432347-44f75cb827c7ce06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><ul>
<li>无序数组<ul>
<li>优点：查询快,如果知道索引可以快速地存取</li>
<li>缺点：删除慢,大小固定</li>
</ul>
</li>
<li>有序数组<ul>
<li>优点：比无序数组查找快</li>
<li>缺点：删除和插入慢，大小固定</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.2 栈</strong><ul>
<li>优点：提供后进先出的存取方式</li>
<li>缺点：存取其他项很慢</li>
<li>比如，Android中管理activity进出就是使用栈</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.3 队列</strong><ul>
<li>优点：提供先进先出的存取方式</li>
<li>缺点：存取其他项都很慢</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.4 链表</strong><ul>
<li>优点：插入快，删除快</li>
<li>缺点：查找慢(一个个节点查)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.5 二叉树</strong><ul>
<li>优点：查找，插入，删除都快（平衡二叉树）</li>
<li>缺点：删除算法复杂</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.6 红-黑树</strong><ul>
<li>优点：查找，插入，删除都快，树总是平衡的(局部调整)</li>
<li>缺点：算法复杂</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.7 哈希表</strong><ul>
<li>优点：如果关键字已知则存取速度极快，插入快</li>
<li>缺点：删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.8 堆</strong><ul>
<li>优点：插入，删除快，对最大数据的项存取很快</li>
<li>缺点：对其他数据项存取很慢</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.9 图</strong><ul>
<li>优点：对现实世界建模</li>
<li>缺点：有些算法慢且复杂</li>
</ul>
</li>
</ul>
<h4 id="3-集合数据结构介绍"><a href="#3-集合数据结构介绍" class="headerlink" title="3.集合数据结构介绍"></a>3.集合数据结构介绍</h4><ul>
<li><strong>3.1 Set集合【一般使用的有TreeSet和HashSet】</strong></li>
<li>3.1.1 TreeSet<ul>
<li>TreeSet是根据二叉树实现的，也就是TreeMap, 放入数据不能重复且不能为null,可以重写compareTo()方法来确定元素大小，从而进行升序排序。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class DataType &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Set&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(new MyComparator());</span><br><span class="line">        treeSet.add(1);</span><br><span class="line">        treeSet.add(3);</span><br><span class="line">        treeSet.add(2);</span><br><span class="line">        for(Integer i : treeSet)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyComparator implements Comparator&lt;Integer&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            if(o1 &lt; o2 )&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(o1 == o2 )&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(o1 &gt; o2 )&#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1.2 HashSet<ul>
<li>HashSet是根据hashCode来决定存储位置的，是通过HashMap实现的，所以对象必须实现hashCode()方法，存储的数据无序不能重复，可以存储null,但是只能存一个。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DataType &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(&quot;1&quot;);</span><br><span class="line">        set.add(&quot;2&quot;);</span><br><span class="line">        set.add(null);</span><br><span class="line">        set.add(&quot;1&quot;);</span><br><span class="line">        for(String s : set)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">null</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.2 List集合【List比较常用的有ArrayList和LinkedList，还有一个比较类似的Vector】</strong></li>
<li>3.2.1 ArrayList<ul>
<li>是使用动态数组来实现的，对于数据的随机get和set或是少量数据的插入或删除，效率会比较高。ArrayList是线程不安全的，在不考虑线程安全的情况下速度也比较快的。ArrayList插入数据可以重复，也是有序的，按照插入的顺序来排序。</li>
<li>根据序号读取数据只需直接获取数组对应脚表的数据</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ListTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">        arrayList.add(&quot;2&quot;);</span><br><span class="line">        arrayList.remove(&quot;1&quot;);</span><br><span class="line">        for(String s : arrayList)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">内部使用动态数组来实现</span><br><span class="line"></span><br><span class="line">/**Shared empty array instance used for empty instances.*/</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">         this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.2.2 LinkedList</strong><ul>
<li>内部是使用链表的形式来实现的,在插入大量数据的时候效率比较快。</li>
<li>LinkedList根据序号获取数据，是二分进行遍历，如果序号小于总长度的一半，就从链表头部开始往后遍历，直到找到对应的序号。如果序号大于总长度的一半，就从链表尾部往前进行遍历，直到找到对应的序号。拿到数据。</li>
<li>链表实现的代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">往容器最后面添加元素的代码是:</span><br><span class="line"> /**</span><br><span class="line">     * Pointer to first node.</span><br><span class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">     *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Pointer to last node.</span><br><span class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">     *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">往容器最前面添加元素的代码</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    if (f == null)</span><br><span class="line">        last = newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">根据序号获取数据：</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    //判断index序号是否是合法的</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;//判断序号在总长度一半之前还是之后</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.2.3 Vector</strong><ul>
<li>Vector的使用方法和内部实现基本和ArrayList相同，只不过它在add(), remove(), get()等方法中都加了同步。所以它是线程安全的。但是使用效率上就不如ArrayList了。</li>
</ul>
</li>
</ul>
<h4 id="4-Map集合【HashMap，TreeMap，HashTable】"><a href="#4-Map集合【HashMap，TreeMap，HashTable】" class="headerlink" title="4.Map集合【HashMap，TreeMap，HashTable】"></a>4.Map集合【HashMap，TreeMap，HashTable】</h4><ul>
<li><strong>4.1 HashMap</strong><ul>
<li>HashMap是基于散列链表来实现的，简单的来说，根据key算出一个hash值，确定一个存放index,但是hash值有可能会冲突重复，所以如果冲突的hash值就需要以链表的形式在同一个index存放了。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(&quot;1&quot;, &quot;a&quot;);//存储</span><br><span class="line">hashMap.put(&quot;2&quot;, &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">hashMap.remove(&quot;1&quot;);//根据key来删除</span><br><span class="line">hashMap.get(&quot;2&quot;);//根据key获取</span><br><span class="line"></span><br><span class="line">//map的遍历,有很多方法遍历,这里只列举一种。</span><br><span class="line">for(Map.Entry&lt;String, String&gt; entry : hashMap.entrySet())&#123;</span><br><span class="line">    entry.getKey();//获取key</span><br><span class="line">    entry.getValue();//获取value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>4.2 TreeMap</strong><ul>
<li>TreeMap的使用大致跟HashMap类似，但是内部实现是根据红黑树来实现的。红黑树是一种平衡有序的二叉树，TreeMap的插入删除查询都是依据红黑树的规则来进行的。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>4.3 HashTable</strong><ul>
<li>HashMap和TreeMap都是线程不安全的，多线程操作的时候可能会造成数据错误。Hashtable是线程安全的。其他内部实现，与HashMap都是一样的。</li>
</ul>
</li>
</ul>
<h3 id="5-Queue队列"><a href="#5-Queue队列" class="headerlink" title="5.Queue队列"></a>5.Queue队列</h3><h4 id="5-1-什么是队列"><a href="#5-1-什么是队列" class="headerlink" title="5.1 什么是队列"></a>5.1 什么是队列</h4><ul>
<li>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</li>
</ul>
<h4 id="5-2-队列的种类"><a href="#5-2-队列的种类" class="headerlink" title="5.2 队列的种类"></a>5.2 队列的种类</h4><ul>
<li><strong>单队列</strong>（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）</li>
<li><strong>循环队列</strong>（避免了“假溢出”的问题）</li>
</ul>
<h4 id="5-3-Java-集合框架中的队列-Queue"><a href="#5-3-Java-集合框架中的队列-Queue" class="headerlink" title="5.3 Java 集合框架中的队列 Queue"></a>5.3 Java 集合框架中的队列 Queue</h4><ul>
<li>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。</li>
</ul>
<h3 id="关于其他内容介绍"><a href="#关于其他内容介绍" class="headerlink" title="关于其他内容介绍"></a>关于其他内容介绍</h3><h4 id="01-关于博客汇总链接"><a href="#01-关于博客汇总链接" class="headerlink" title="01.关于博客汇总链接"></a>01.关于博客汇总链接</h4><ul>
<li>1.<a href="https://www.jianshu.com/p/614cb839182c" target="_blank" rel="noopener">技术博客汇总</a></li>
<li>2.<a href="https://blog.csdn.net/m0_37700275/article/details/80863574" target="_blank" rel="noopener">开源项目汇总</a></li>
<li>3.<a href="https://blog.csdn.net/m0_37700275/article/details/79832978" target="_blank" rel="noopener">生活博客汇总</a></li>
<li>4.<a href="https://www.jianshu.com/p/f665de16d1eb" target="_blank" rel="noopener">喜马拉雅音频汇总</a></li>
<li>5.<a href="https://www.jianshu.com/p/53017c3fc75d" target="_blank" rel="noopener">其他汇总</a></li>
</ul>
<h4 id="02-关于我的博客"><a href="#02-关于我的博客" class="headerlink" title="02.关于我的博客"></a>02.关于我的博客</h4><ul>
<li>我的个人站点：<a href="http://www.yczbj.org，www.ycbjie.cn" target="_blank" rel="noopener">www.yczbj.org，www.ycbjie.cn</a></li>
<li>github：<a href="https://github.com/yangchong211" target="_blank" rel="noopener">https://github.com/yangchong211</a></li>
<li>知乎：<a href="https://www.zhihu.com/people/yang-chong-69-24/pins/posts" target="_blank" rel="noopener">https://www.zhihu.com/people/yang-chong-69-24/pins/posts</a></li>
<li>简书：<a href="http://www.jianshu.com/u/b7b2c6ed9284" target="_blank" rel="noopener">http://www.jianshu.com/u/b7b2c6ed9284</a></li>
<li>csdn：<a href="http://my.csdn.net/m0_37700275" target="_blank" rel="noopener">http://my.csdn.net/m0_37700275</a></li>
<li>喜马拉雅听书：<a href="http://www.ximalaya.com/zhubo/71989305/" target="_blank" rel="noopener">http://www.ximalaya.com/zhubo/71989305/</a></li>
<li>开源中国：<a href="https://my.oschina.net/zbj1618/blog" target="_blank" rel="noopener">https://my.oschina.net/zbj1618/blog</a></li>
<li>泡在网上的日子：<a href="http://www.jcodecraeer.com/member/content_list.php?channelid=1" target="_blank" rel="noopener">http://www.jcodecraeer.com/member/content_list.php?channelid=1</a></li>
<li>邮箱：<a href="mailto:yangchong211@163.com" target="_blank" rel="noopener">yangchong211@163.com</a></li>
<li>阿里云博客：<a href="https://yq.aliyun.com/users/article?spm=5176.100-" target="_blank" rel="noopener">https://yq.aliyun.com/users/article?spm=5176.100-</a> 239.headeruserinfo.3.dT4bcV</li>
<li>segmentfault头条：<a href="https://segmentfault.com/u/xiangjianyu/articles" target="_blank" rel="noopener">https://segmentfault.com/u/xiangjianyu/articles</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2017/11/20/java/dataStructure/01.baseDataStructure/" data-id="ckkrzb8y4002xcv2adjbsnt2w" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2017/11/20/java/dataStructure/02.baseDataStructure2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          java常用数据结构深度解析
        
      </div>
    </a>
  
  
    <a href="/2017/11/20/java/reflex/deepReflex/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">深入理解反射</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#目录结构"><span class="toc-number">1.</span> <span class="toc-text">目录结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-常用数据有哪些？"><span class="toc-number">1.1.</span> <span class="toc-text">1.常用数据有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-数据的说明"><span class="toc-number">1.2.</span> <span class="toc-text">2.数据的说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-集合数据结构介绍"><span class="toc-number">1.3.</span> <span class="toc-text">3.集合数据结构介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Map集合【HashMap，TreeMap，HashTable】"><span class="toc-number">1.4.</span> <span class="toc-text">4.Map集合【HashMap，TreeMap，HashTable】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Queue队列"><span class="toc-number">2.</span> <span class="toc-text">5.Queue队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-什么是队列"><span class="toc-number">2.1.</span> <span class="toc-text">5.1 什么是队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-队列的种类"><span class="toc-number">2.2.</span> <span class="toc-text">5.2 队列的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-Java-集合框架中的队列-Queue"><span class="toc-number">2.3.</span> <span class="toc-text">5.3 Java 集合框架中的队列 Queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于其他内容介绍"><span class="toc-number">3.</span> <span class="toc-text">关于其他内容介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01-关于博客汇总链接"><span class="toc-number">3.1.</span> <span class="toc-text">01.关于博客汇总链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02-关于我的博客"><span class="toc-number">3.2.</span> <span class="toc-text">02.关于我的博客</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 popc&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;cc5853235@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>