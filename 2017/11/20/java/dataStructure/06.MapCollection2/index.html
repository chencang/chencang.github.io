<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Map集合深度解析 | 飞翔的企鹅</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录介绍 1.问题解答答疑 2.Map集合整体结构 2.1 Map集合整体结构图形 2.2 整体结构介绍   3.Map集合部分源码分析 3.1 HashMap 内部的结构 3.2 HashMap(int initialCapacity, float loadFactor) 3.3 put(K key, V value)代码解析 3.4 final Node&amp;lt;K,V&amp;gt;[] resize">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="Map集合深度解析">
<meta property="og:url" content="https://blog.okjvm.com/2017/11/20/java/dataStructure/06.MapCollection2/index.html">
<meta property="og:site_name" content="飞翔的企鹅">
<meta property="og:description" content="目录介绍 1.问题解答答疑 2.Map集合整体结构 2.1 Map集合整体结构图形 2.2 整体结构介绍   3.Map集合部分源码分析 3.1 HashMap 内部的结构 3.2 HashMap(int initialCapacity, float loadFactor) 3.3 put(K key, V value)代码解析 3.4 final Node&amp;lt;K,V&amp;gt;[] resize">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4432347-36193cefea2a5f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4432347-f43d61f063f453c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-03-17T12:44:29.430Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Map集合深度解析">
<meta name="twitter:description" content="目录介绍 1.问题解答答疑 2.Map集合整体结构 2.1 Map集合整体结构图形 2.2 整体结构介绍   3.Map集合部分源码分析 3.1 HashMap 内部的结构 3.2 HashMap(int initialCapacity, float loadFactor) 3.3 put(K key, V value)代码解析 3.4 final Node&amp;lt;K,V&amp;gt;[] resize">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/4432347-36193cefea2a5f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="飞翔的企鹅" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.okjvm.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">飞翔的企鹅</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎访问</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java/dataStructure/06.MapCollection2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/20/java/dataStructure/06.MapCollection2/" class="article-date">
  <time datetime="2017-11-20T10:00:59.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Map集合深度解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.问题解答答疑</li>
<li>2.Map集合整体结构<ul>
<li>2.1 Map集合整体结构图形</li>
<li>2.2 整体结构介绍</li>
</ul>
</li>
<li>3.Map集合部分源码分析<ul>
<li>3.1 HashMap 内部的结构</li>
<li>3.2 HashMap(int initialCapacity, float loadFactor)</li>
<li>3.3 put(K key, V value)代码解析</li>
<li>3.4 final Node&lt;K,V&gt;[] resize()</li>
</ul>
</li>
<li>4.Map集合容量和负载因子</li>
<li>5.Map集合性能分析<ul>
<li>5.1 Map集合性能</li>
<li>5.2 HashTable和HashMap初始化与增长方式</li>
</ul>
</li>
<li>6.解决哈希冲突有哪些典型方法呢？</li>
<li>7.其他常见问题<ul>
<li>7.1 HashTable和HashMap线程安全性</li>
<li>7.2 HashMap集合深入概况</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="1-问题解答答疑"><a href="#1-问题解答答疑" class="headerlink" title="1.问题解答答疑"></a>1.问题解答答疑</h3><ul>
<li>1.0.0 对比 Hashtable、HashMap、TreeMap 有何区别？<ul>
<li>Hashtable 是早期 Java 类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</li>
<li>HashMap 是应用更加广泛的哈希表实现，行为上大致上与 HashTable 一致，主要区别在于HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选。</li>
<li>TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</li>
</ul>
</li>
<li>1.0.1 HashMap在并发环境可能出现无限循环占用CPU、size不准确等诡异的问题？<ul>
<li>典型的使用错误，因为 HashMap 明确声明不是线程安全的的数据结构，如果忽略这一点，简单用在多线程场景里，难免会出现问题。</li>
</ul>
</li>
</ul>
<h3 id="2-Map集合整体结构"><a href="#2-Map集合整体结构" class="headerlink" title="2.Map集合整体结构"></a>2.Map集合整体结构</h3><h4 id="2-1-Map集合整体结构图形"><a href="#2-1-Map集合整体结构图形" class="headerlink" title="2.1 Map集合整体结构图形"></a>2.1 Map集合整体结构图形</h4><p><img src="https://upload-images.jianshu.io/upload_images/4432347-36193cefea2a5f0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<h4 id="2-2-整体结构介绍"><a href="#2-2-整体结构介绍" class="headerlink" title="2.2 整体结构介绍"></a>2.2 整体结构介绍</h4><ul>
<li>HashMap 等其他 Map 实现则是都扩展了AbstractMap，里面包含了通用方法抽象。不同 Map的用途，从类图结构就能体现出来，设计目的已经体现在不同接口上。</li>
<li>Hashtable 比较特别，作为类似 Vector、Stack 的早期集合相关类型，它是扩展了 Dictionary 类的，类结构上与 HashMap 之类明显不同。</li>
<li>大部分使用 Map 的场景，通常就是放入、访问或者删除，而对顺序没有特别要求，HashMap 在这种情况下基本是最好的选择。HashMap的性能表现非常依赖于哈希码的有效性，请务必掌握hashCode 和 equals 的一些基本约定，比如：<ul>
<li>equals 相等，hashCode 一定要相等。</li>
<li>重写了 hashCode 也要重写 equals。</li>
<li>hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。</li>
<li>equals 的对称、反射、传递等特性。</li>
</ul>
</li>
</ul>
<h3 id="3-Map集合部分源码分析"><a href="#3-Map集合部分源码分析" class="headerlink" title="3.Map集合部分源码分析"></a>3.Map集合部分源码分析</h3><h4 id="3-1-HashMap-内部的结构"><a href="#3-1-HashMap-内部的结构" class="headerlink" title="3.1 HashMap 内部的结构"></a>3.1 HashMap 内部的结构</h4><ul>
<li>HashMap 内部的结构，它可以看作是数组（Node[] table）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，你可以参考下面的示意图。这里需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8，图中的链表就会被改造为树形结构。</li>
<li><img src="https://upload-images.jianshu.io/upload_images/4432347-f43d61f063f453c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<h4 id="3-2-HashMap-int-initialCapacity-float-loadFactor"><a href="#3-2-HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="3.2 HashMap(int initialCapacity, float loadFactor)"></a>3.2 HashMap(int initialCapacity, float loadFactor)</h4><ul>
<li>HashMap 也许是按照 lazy-load 原则，在首次使用时被初始化（拷贝构造函数除外，我这里仅介绍最通用的场景）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-3-put-K-key-V-value-代码解析"><a href="#3-3-put-K-key-V-value-代码解析" class="headerlink" title="3.3 put(K key, V value)代码解析"></a>3.3 put(K key, V value)代码解析</h4><ul>
<li>如果表格是 null，resize 方法会负责初始化它，这从 tab = resize() 可以看出。</li>
<li>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。</li>
<li>在放置新的键值对的过程中，如果发生if (++size &gt; threshold)条件，就会发生扩容。</li>
<li>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：i = (n - 1) &amp; hash</li>
<li>仔细观察哈希值的源头，我们会发现，它并不是 key 本身的hashCode，而是来自于 HashMap 内部的另外一个 hash 方法。注意，为什么这里需要将高位数据移位到低位进行异或运算呢？这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash(key)调用了下面这个静态方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-4-final-Node-lt-K-V-gt-resize"><a href="#3-4-final-Node-lt-K-V-gt-resize" class="headerlink" title="3.4 final Node&lt;K,V&gt;[] resize()"></a>3.4 final Node&lt;K,V&gt;[] resize()</h4><ul>
<li>初始化或加倍表大小。如果为NULL，则按照在字段阈值中保持的初始容量目标分配。否则，由于我们使用的是二次幂展开，每个bin中的元素要么保持在相同的索引中，要么在新表中以两个偏移的幂移动。</li>
<li>依据 resize 源码，不考虑极端情况（容量理论最大极限由MAXIMUM_CAPACITY 指定，数值为1&lt;&lt;30，也就是 2 的 30 次方），可以归纳为：<ul>
<li>门限值等于（负载因子）x（容量），如果构建 HashMap的时候没有指定它们，那么就是依据相应的默认常量值。</li>
<li>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），我前面提到，根据 putVal 的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li>
<li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Map集合容量和负载因子"><a href="#4-Map集合容量和负载因子" class="headerlink" title="4.Map集合容量和负载因子"></a>4.Map集合容量和负载因子</h3><h3 id="5-Map集合性能分析"><a href="#5-Map集合性能分析" class="headerlink" title="5.Map集合性能分析"></a>5.Map集合性能分析</h3><h4 id="5-2-HashTable和HashMap初始化与增长方式"><a href="#5-2-HashTable和HashMap初始化与增长方式" class="headerlink" title="5.2 HashTable和HashMap初始化与增长方式"></a>5.2 HashTable和HashMap初始化与增长方式</h4><ul>
<li>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。</li>
<li>扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。</li>
</ul>
<h3 id="6-解决哈希冲突有哪些典型方法呢？"><a href="#6-解决哈希冲突有哪些典型方法呢？" class="headerlink" title="6.解决哈希冲突有哪些典型方法呢？"></a>6.解决哈希冲突有哪些典型方法呢？</h3><h4 id="6-1-开放定址法"><a href="#6-1-开放定址法" class="headerlink" title="6.1 开放定址法"></a>6.1 开放定址法</h4><ul>
<li>基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</li>
</ul>
<h4 id="6-2-再哈希法"><a href="#6-2-再哈希法" class="headerlink" title="6.2 再哈希法"></a>6.2 再哈希法</h4><ul>
<li>这种方法是同时构造多个不同的哈希函数：</li>
<li>Hi=RH1（key）  i=1，2，…，k</li>
<li>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</li>
</ul>
<h4 id="6-3-链地址法"><a href="#6-3-链地址法" class="headerlink" title="6.3 链地址法"></a>6.3 链地址法</h4><ul>
<li>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</li>
</ul>
<h4 id="6-4-建立公共溢出区"><a href="#6-4-建立公共溢出区" class="headerlink" title="6.4 建立公共溢出区"></a>6.4 建立公共溢出区</h4><ul>
<li>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li>
</ul>
<h3 id="7-其他常见问题"><a href="#7-其他常见问题" class="headerlink" title="7.其他常见问题"></a>7.其他常见问题</h3><h4 id="7-1-HashTable和HashMap线程安全性"><a href="#7-1-HashTable和HashMap线程安全性" class="headerlink" title="7.1 HashTable和HashMap线程安全性"></a>7.1 HashTable和HashMap线程安全性</h4><ul>
<li>HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。</li>
<li>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步（1）可以用Collections的synchronizedMap方法；（2）使用ConcurrentHashMap类，相较于HashTable锁住的是对象整体，ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。</li>
</ul>
<h4 id="7-2-HashMap集合深入概况"><a href="#7-2-HashMap集合深入概况" class="headerlink" title="7.2 HashMap集合深入概况"></a>7.2 HashMap集合深入概况</h4><ul>
<li>HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值（TREEIFY_THRESHOLD,8），链表就会被改造为树形结构。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.okjvm.com/2017/11/20/java/dataStructure/06.MapCollection2/" data-id="ckkrzb8y6002zcv2a3s54xk87" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2017/11/20/java/dataStructure/07.ConcurrentHashMap/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          ConcurrentHashMap
        
      </div>
    </a>
  
  
    <a href="/2017/11/20/java/dataStructure/05.MapCollection/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Map集合基础介绍</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
     
       
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#目录介绍"><span class="toc-number">1.</span> <span class="toc-text">目录介绍</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#1-问题解答答疑"><span class="toc-number"></span> <span class="toc-text">1.问题解答答疑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Map集合整体结构"><span class="toc-number"></span> <span class="toc-text">2.Map集合整体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Map集合整体结构图形"><span class="toc-number">1.</span> <span class="toc-text">2.1 Map集合整体结构图形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-整体结构介绍"><span class="toc-number">2.</span> <span class="toc-text">2.2 整体结构介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Map集合部分源码分析"><span class="toc-number"></span> <span class="toc-text">3.Map集合部分源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-HashMap-内部的结构"><span class="toc-number">1.</span> <span class="toc-text">3.1 HashMap 内部的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-HashMap-int-initialCapacity-float-loadFactor"><span class="toc-number">2.</span> <span class="toc-text">3.2 HashMap(int initialCapacity, float loadFactor)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-put-K-key-V-value-代码解析"><span class="toc-number">3.</span> <span class="toc-text">3.3 put(K key, V value)代码解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-final-Node-lt-K-V-gt-resize"><span class="toc-number">4.</span> <span class="toc-text">3.4 final Node&lt;K,V&gt;[] resize()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Map集合容量和负载因子"><span class="toc-number"></span> <span class="toc-text">4.Map集合容量和负载因子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Map集合性能分析"><span class="toc-number"></span> <span class="toc-text">5.Map集合性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-HashTable和HashMap初始化与增长方式"><span class="toc-number">1.</span> <span class="toc-text">5.2 HashTable和HashMap初始化与增长方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-解决哈希冲突有哪些典型方法呢？"><span class="toc-number"></span> <span class="toc-text">6.解决哈希冲突有哪些典型方法呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-开放定址法"><span class="toc-number">1.</span> <span class="toc-text">6.1 开放定址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-再哈希法"><span class="toc-number">2.</span> <span class="toc-text">6.2 再哈希法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-链地址法"><span class="toc-number">3.</span> <span class="toc-text">6.3 链地址法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-建立公共溢出区"><span class="toc-number">4.</span> <span class="toc-text">6.4 建立公共溢出区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-其他常见问题"><span class="toc-number"></span> <span class="toc-text">7.其他常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-HashTable和HashMap线程安全性"><span class="toc-number">1.</span> <span class="toc-text">7.1 HashTable和HashMap线程安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-HashMap集合深入概况"><span class="toc-number">2.</span> <span class="toc-text">7.2 HashMap集合深入概况</span></a></li></ol>
          </li></div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 popc&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;cc5853235@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->



 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>