<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这里是介绍"><title>多线程基础 | 飞翔的企鹅</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">多线程基础</h1><a id="logo" href="/.">飞翔的企鹅</a><p class="description">欢迎访问</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">多线程基础</h1><div class="post-meta">Nov 21, 2018</div><div class="post-content"><h4 id="多线程基础知识"><a href="#多线程基础知识" class="headerlink" title="多线程基础知识"></a>多线程基础知识</h4><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul>
<li><strong>0.先来看几个问题[思考]</strong></li>
<li><strong>1.进程概述及多进程的意义[理解]</strong><ul>
<li>1.1 线程和进程</li>
<li>1.2 进程概述</li>
<li>1.3 多进程的意义</li>
</ul>
</li>
<li><strong>2.线程的概述和多线程的意义[理解]</strong><ul>
<li>2.1 什么是线程</li>
<li>2.2 多线程有什么意义</li>
<li>2.3 并行和并发</li>
</ul>
</li>
<li><strong>3.JVM运行原理以及JVM启动的线程探讨[理解]</strong><ul>
<li>3.1 Java程序运行原理</li>
<li>3.2 JVM的启动是多线程的吗</li>
</ul>
</li>
<li><strong>4.多线程程序实现的方式[掌握]</strong><ul>
<li><strong>4.1 多线程程序实现的方式【重点】</strong></li>
</ul>
<ul>
<li>4.1.1 第一种方式：是类继承Thread</li>
<li>4.1.2 第二种方式：是实现接口Runnable</li>
<li>4.2 多线程两种方式的区别</li>
<li>4.3 几个小问题探索</li>
<li>4.4 匿名内部类的方式实现多线程程序</li>
</ul>
</li>
<li><strong>5.线程调度</strong><ul>
<li>5.1 线程的调度问题</li>
<li>5.2 线程有两种调度模型</li>
</ul>
</li>
<li><strong>6.线程控制</strong><ul>
<li>6.1 线程控制之休眠线程</li>
<li>6.2 线程控制之加入线程</li>
<li>6.3 线程控制之礼让线程</li>
<li>6.4 线程控制之守护线程</li>
<li>6.5 线程控制之中断线程</li>
</ul>
</li>
<li><strong>7.案例分析</strong><ul>
<li>7.1 继承Thread类的方式卖电影票案例</li>
<li>7.2 实现Runnable接口的方式卖电影票</li>
<li>7.3 买电影票出现了同票和负数票的原因分析</li>
<li>7.4 线程安全问题的产生原因分析</li>
<li>7.5 同步代码块的方式解决线程安全问题</li>
</ul>
</li>
<li><strong>8.关于思考问题解答</strong></li>
</ul>
<h3 id="0-前沿介绍"><a href="#0-前沿介绍" class="headerlink" title="0.前沿介绍"></a>0.前沿介绍</h3><ul>
<li><strong>关于线程池关联博客有：</strong></li>
<li><a href="http://www.jcodecraeer.com/plus/view.php?aid=9597" target="_blank" rel="noopener">多线程1，线程基础知识</a></li>
<li><a href="http://www.jcodecraeer.com/plus/view.php?aid=9604" target="_blank" rel="noopener">多线程2，线程池深入理解</a></li>
<li><a href="https://blog.csdn.net/m0_37700275/article/details/79979097" target="_blank" rel="noopener">多线程3，线程池封装库</a></li>
<li>如果觉得前两篇线程知识太基础，可以直接忽略……主要是回顾基础知识点！</li>
</ul>
<h3 id="0-先来看几个问题-思考"><a href="#0-先来看几个问题-思考" class="headerlink" title="0.先来看几个问题[思考]"></a>0.先来看几个问题[思考]</h3><ul>
<li>a.wait()和sleep()的区别？</li>
</ul>
<h3 id="1-进程概述及多进程的意义-理解"><a href="#1-进程概述及多进程的意义-理解" class="headerlink" title="1.进程概述及多进程的意义[理解]"></a>1.进程概述及多进程的意义[理解]</h3><h4 id="1-1-线程和进程"><a href="#1-1-线程和进程" class="headerlink" title="1.1 线程和进程"></a>1.1 线程和进程</h4><ul>
<li>要想说线程，首先必须得聊聊进程，因为线程是依赖于进程存在的。</li>
</ul>
<h4 id="1-2-进程概述"><a href="#1-2-进程概述" class="headerlink" title="1.2 进程概述"></a>1.2 进程概述</h4><ul>
<li>什么是进程呢?通过任务管理器我们就可以看到进程的存在。</li>
<li>概念：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。</li>
</ul>
<h4 id="1-3-多进程的意义"><a href="#1-3-多进程的意义" class="headerlink" title="1.3 多进程的意义"></a>1.3 多进程的意义</h4><ul>
<li>单进程计算机只能做一件事情。而我们现在的计算机都可以一边玩游戏(游戏进程),一边听音乐(音乐进程)，所以我们常见的操作系统都是多进程操作系统。比如：Windows，Mac和Linux等，能在同一个时间段内执行多个任务。</li>
<li>对于单核计算机来讲，游戏进程和音乐进程是同时运行的吗?不是。</li>
<li>因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，</li>
<li>所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。多进程的作用不是提高执行速度，而是提高CPU的使用率。</li>
</ul>
<h3 id="2-线程的概述和多线程的意义-理解"><a href="#2-线程的概述和多线程的意义-理解" class="headerlink" title="2.线程的概述和多线程的意义[理解]"></a>2.线程的概述和多线程的意义[理解]</h3><h4 id="2-1-什么是线程"><a href="#2-1-什么是线程" class="headerlink" title="2.1 什么是线程"></a>2.1 什么是线程</h4><ul>
<li>在一个进程内部又可以执行多个任务，而这每一个任务我们就可以看成是一个线程。是程序使用CPU的基本单位。</li>
</ul>
<h4 id="2-2-多线程有什么意义"><a href="#2-2-多线程有什么意义" class="headerlink" title="2.2 多线程有什么意义"></a>2.2 多线程有什么意义</h4><ul>
<li>多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。</li>
<li>那么怎么理解这个问题呢?我们程序在运行的使用,都是在抢CPU的时间片(执行权),如果是多线程的程序,那么在抢到CPU的执行权的概率应该比较单线程程序抢到的概率要大.那么也就是说,CPU在多线程程序中执行的时间要比单线程多,所以就提高了程序的使用率.但是即使是多线程程序,那么他们中的哪个线程能抢占到CPU的资源呢,这个是不确定的,所以多线程具有随机性.</li>
</ul>
<h4 id="2-3-并行和并发"><a href="#2-3-并行和并发" class="headerlink" title="2.3 并行和并发"></a>2.3 并行和并发</h4><ul>
<li>前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。</li>
<li>后者是物理上同时发生，指在某一个时间点同时运行多个程序。</li>
</ul>
<h3 id="3-JVM运行原理以及JVM启动的线程探讨-理解"><a href="#3-JVM运行原理以及JVM启动的线程探讨-理解" class="headerlink" title="3.JVM运行原理以及JVM启动的线程探讨[理解]"></a>3.JVM运行原理以及JVM启动的线程探讨[理解]</h3><h4 id="3-1-Java程序运行原理"><a href="#3-1-Java程序运行原理" class="headerlink" title="3.1 Java程序运行原理"></a>3.1 Java程序运行原理</h4><ul>
<li>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。</li>
<li>该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。</li>
</ul>
<h4 id="3-2-JVM的启动是多线程的吗"><a href="#3-2-JVM的启动是多线程的吗" class="headerlink" title="3.2 JVM的启动是多线程的吗"></a>3.2 JVM的启动是多线程的吗</h4><ul>
<li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li>
</ul>
<h3 id="4-多线程程序实现的方式-掌握"><a href="#4-多线程程序实现的方式-掌握" class="headerlink" title="4.多线程程序实现的方式[掌握]"></a>4.多线程程序实现的方式[掌握]</h3><h4 id="4-1-多线程程序实现的方式"><a href="#4-1-多线程程序实现的方式" class="headerlink" title="4.1 多线程程序实现的方式"></a>4.1 多线程程序实现的方式</h4><ul>
<li><strong>4.1.1 第一种方式：是类继承Thread</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式的步骤:</span></span><br><span class="line"><span class="comment">//1: 定义一个类,让该类去继承Thread类</span></span><br><span class="line"><span class="comment">//2: 重写run方法</span></span><br><span class="line"><span class="comment">//3: 创建该类的对象</span></span><br><span class="line"><span class="comment">//4: 启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建对象</span></span><br><span class="line">		MyThread t1 = <span class="keyword">new</span> MyThread() ;</span><br><span class="line">		MyThread t2 = <span class="keyword">new</span> MyThread() ;</span><br><span class="line">		<span class="comment">// 启动线程: 需要使用start方法启动线程, 如果我们在这里调用的是run方法,那么我们只是把该方法作为普通方法进行执行</span></span><br><span class="line"><span class="comment">//		t1.run() ;</span></span><br><span class="line"><span class="comment">//		t1.run() ;</span></span><br><span class="line">		t1.start() ;		<span class="comment">// 告诉jvm开启一个线程调用run方法</span></span><br><span class="line">		<span class="comment">// t1.start() ;		// 一个线程只能被启动一次</span></span><br><span class="line">		t2.start() ;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">1000</span> ; x++) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>4.1.2 第二种方式：是实现接口Runnable</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现多线程的第二中方式步骤:</span></span><br><span class="line"><span class="comment">//1: 定义一个类,让该类去实现Runnable接口</span></span><br><span class="line"><span class="comment">//2: 重写run方法</span></span><br><span class="line"><span class="comment">//3: 创建定义的类的对象</span></span><br><span class="line"><span class="comment">//4: 创建Thread的对象吧第三步创建的对象作为参数传递进来</span></span><br><span class="line"><span class="comment">//5: 启动线程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建定义的类的对象</span></span><br><span class="line">	MyThread mt = <span class="keyword">new</span> MyThread() ;</span><br><span class="line">	<span class="comment">// 创建Thread的对象吧第三步创建的对象作为参数传递进来</span></span><br><span class="line">	Thread t1 = <span class="keyword">new</span> Thread(mt , <span class="string">"张三"</span>) ;</span><br><span class="line">	Thread t2 = <span class="keyword">new</span> Thread(mt , <span class="string">"李四"</span>) ;</span><br><span class="line">	<span class="comment">// 启动线程</span></span><br><span class="line">	t1.start() ;</span><br><span class="line">	t2.start() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">1000</span> ; x++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">"---"</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-多线程两种方式的区别"><a href="#4-2-多线程两种方式的区别" class="headerlink" title="4.2 多线程两种方式的区别"></a>4.2 多线程两种方式的区别</h4><ul>
<li>run()方法只是调用了Thread实例的run()方法而已，它仍然运行在主线程上，而start()方法会开辟一个新的线程，在新的线程上调用run()方法，此时它运行在新的线程上。</li>
</ul>
<h4 id="4-3-几个小问题探索"><a href="#4-3-几个小问题探索" class="headerlink" title="4.3 几个小问题探索"></a>4.3 几个小问题探索</h4><ul>
<li><strong>4.3.1 为什么要重写run方法</strong></li>
<li>可以在定义的类中,定义多个方法,而方法中的代码并不是所有的都需要线程来进行执行; 如果我们想让某一个段代码被线程,那么我们只需要将那一段代码放在run方法中。那么也就是说run方法中封装的都是要被线程执行的代码 ; </li>
<li>run方法中的代码的特点: 封装的都是一些比较耗时的代码</li>
</ul>
<ul>
<li><strong>4.3.2 线程能不能多次启动</strong></li>
<li>一个线程只能被启动一次</li>
</ul>
<ul>
<li><strong>4.3.2 run()和start()方法的区别</strong></li>
<li>启动线程: 需要使用start方法启动线程， 如果我们在这里调用的是run方法，那么我们只是把该方法作为普通方法进行执行。</li>
</ul>
<h4 id="4-4-匿名内部类的方式实现多线程程序"><a href="#4-4-匿名内部类的方式实现多线程程序" class="headerlink" title="4.4 匿名内部类的方式实现多线程程序"></a>4.4 匿名内部类的方式实现多线程程序</h4><ul>
<li>new Thread(){代码…}.start();</li>
<li>new Thread(new Runnable(){代码…}).start();</li>
</ul>
<h3 id="5-线程调度"><a href="#5-线程调度" class="headerlink" title="5.线程调度"></a>5.线程调度</h3><h4 id="5-1-线程的调度问题"><a href="#5-1-线程的调度问题" class="headerlink" title="5.1 线程的调度问题"></a>5.1 线程的调度问题</h4><ul>
<li>应用程序在执行的时候都需要依赖于线程去抢占CPU的时间片 , 谁抢占到了CPU的时间片,那么CPU就会执行谁</li>
<li>线程的执行：假如我们的计算机只有一个 CPU，那么 CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。</li>
</ul>
<h4 id="5-2-线程有两种调度模型"><a href="#5-2-线程有两种调度模型" class="headerlink" title="5.2 线程有两种调度模型"></a>5.2 线程有两种调度模型</h4><ul>
<li><strong>5.2.1 分时调度模型</strong>     </li>
<li>所有线程轮流使用CPU的使用权，平均分配每个线程占用 CPU 的时间片</li>
<li><strong>5.2.2 抢占式调度模型</strong></li>
<li>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。Java使用的是抢占式调度模型。</li>
</ul>
<h3 id="6-线程控制"><a href="#6-线程控制" class="headerlink" title="6.线程控制"></a>6.线程控制</h3><h4 id="6-1-线程控制之休眠线程"><a href="#6-1-线程控制之休眠线程" class="headerlink" title="6.1 线程控制之休眠线程"></a>6.1 线程控制之休眠线程</h4><ul>
<li>public static void sleep(long time) ;    </li>
<li>time表达的意思是休眠的时间 , 单位是毫秒</li>
</ul>
<h4 id="6-2-线程控制之加入线程"><a href="#6-2-线程控制之加入线程" class="headerlink" title="6.2 线程控制之加入线程"></a>6.2 线程控制之加入线程</h4><ul>
<li>public final void join()</li>
<li>等待该线程执行完毕了以后,其他线程才能再次执行</li>
<li><strong>注意事项: 在线程启动之后,在调用方法</strong></li>
</ul>
<h4 id="6-3-线程控制之礼让线程"><a href="#6-3-线程控制之礼让线程" class="headerlink" title="6.3 线程控制之礼让线程"></a>6.3 线程控制之礼让线程</h4><ul>
<li>public static void yield():    </li>
<li>暂停当前正在执行的线程对象，并执行其他线程。 </li>
<li>线程礼让的原理是: 暂定当前的线程,然CPU去执行其他的线程, 这个暂定的时间是相当短暂的; 当我某一个线程暂定完毕以后,其他的线程还没有抢占到cpu的执行权 ; 那么这个是时候当前的线程会和其他的线程再次抢占cpu的执行权; </li>
</ul>
<h4 id="6-4-线程控制之守护线程"><a href="#6-4-线程控制之守护线程" class="headerlink" title="6.4 线程控制之守护线程"></a>6.4 线程控制之守护线程</h4><ul>
<li>public final void setDaemon(boolean on)</li>
<li>将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。</li>
<li>jvm会线程程序中存在的线程类型,如果线程全部是守护线程,那么jvm就停止。</li>
</ul>
<h4 id="6-5-线程控制之中断线程"><a href="#6-5-线程控制之中断线程" class="headerlink" title="6.5 线程控制之中断线程"></a>6.5 线程控制之中断线程</h4><ul>
<li>public final void stop():        </li>
<li>停止线程的运行</li>
<li>public void interrupt():        </li>
<li>中断线程(这个翻译不太好),查看API可得当线程调用wait(),sleep(long time)方法的时候处于阻塞状态,可以通过这个方法清除阻塞</li>
</ul>
<h3 id="7-案例分析"><a href="#7-案例分析" class="headerlink" title="7.案例分析"></a>7.案例分析</h3><h4 id="7-1-继承Thread类的方式卖电影票案例"><a href="#7-1-继承Thread类的方式卖电影票案例" class="headerlink" title="7.1 继承Thread类的方式卖电影票案例"></a>7.1 继承Thread类的方式卖电影票案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 需求：某电影院目前正在上映贺岁大片，共有100张票，而它有3个售票窗口售票，请设计一个程序模拟该电影院售票。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 创建3个线程对象</span></span><br><span class="line">		SellTicktes t1 = <span class="keyword">new</span> SellTicktes() ;</span><br><span class="line">		SellTicktes t2 = <span class="keyword">new</span> SellTicktes() ;</span><br><span class="line">		SellTicktes t3 = <span class="keyword">new</span> SellTicktes() ;</span><br><span class="line">		<span class="comment">// 设置名称</span></span><br><span class="line">		t1.setName(<span class="string">"窗口1"</span>) ;</span><br><span class="line">		t2.setName(<span class="string">"窗口2"</span>) ;</span><br><span class="line">		t3.setName(<span class="string">"窗口3"</span>) ;</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start() ;</span><br><span class="line">		t2.start() ;</span><br><span class="line">		t3.start() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicktes</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span> ;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 定义总票数</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 如果我们把票数定义成了局部变量,那么表示的意思是每一个窗口出售了各自的100张票; 而我们的需求是: 总共有100张票</span></span><br><span class="line"><span class="comment">		 * 而这100张票要被3个窗口出售; 因此我们就不能把票数定义成局部变量,只能定义成成员变量</span></span><br><span class="line"><span class="comment">		 */</span>		</span><br><span class="line">		<span class="comment">// 模拟售票</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>( num &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售"</span> + (num--) + <span class="string">"张票"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-实现Runnable接口的方式卖电影票"><a href="#7-2-实现Runnable接口的方式卖电影票" class="headerlink" title="7.2 实现Runnable接口的方式卖电影票"></a>7.2 实现Runnable接口的方式卖电影票</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicektesDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建SellTicektes对象</span></span><br><span class="line">		SellTicektes st = <span class="keyword">new</span> SellTicektes() ;</span><br><span class="line">		<span class="comment">// 创建Thread对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st , <span class="string">"窗口1"</span>) ;</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st , <span class="string">"窗口2"</span>) ;</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(st , <span class="string">"窗口3"</span>) ;</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start() ;</span><br><span class="line">		t2.start() ;</span><br><span class="line">		t3.start() ;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicektes</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span> ;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span> + (num--) + <span class="string">"张票"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-买电影票出现了同票和负数票的原因分析"><a href="#7-3-买电影票出现了同票和负数票的原因分析" class="headerlink" title="7.3 买电影票出现了同票和负数票的原因分析"></a>7.3 买电影票出现了同票和负数票的原因分析</h4><ul>
<li>讲解过电影院售票程序，从表面上看不出什么问题，但是在真实生活中，售票时网络是不能实时传输的，总是存在延迟的情况，所以，在出售一张票以后，需要一点时间的延迟。改实现接口方式的卖票程序,每次卖票延迟100毫秒<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建3个线程对象</span></span><br><span class="line">		SellTicktes t1 = <span class="keyword">new</span> SellTicktes() ;</span><br><span class="line">		SellTicktes t2 = <span class="keyword">new</span> SellTicktes() ;</span><br><span class="line">		SellTicktes t3 = <span class="keyword">new</span> SellTicktes() ;</span><br><span class="line">		<span class="comment">// 设置名称</span></span><br><span class="line">		t1.setName(<span class="string">"窗口1"</span>) ;</span><br><span class="line">		t2.setName(<span class="string">"窗口2"</span>) ;</span><br><span class="line">		t3.setName(<span class="string">"窗口3"</span>) ;</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start() ;</span><br><span class="line">		t2.start() ;</span><br><span class="line">		t3.start() ;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicktes</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span> ;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 模拟售票</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>( num &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>) ;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售"</span> + (num--) + <span class="string">"张票"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-4-线程安全问题的产生原因分析"><a href="#7-4-线程安全问题的产生原因分析" class="headerlink" title="7.4 线程安全问题的产生原因分析"></a>7.4 线程安全问题的产生原因分析</h4><ul>
<li>7.4.1 首先想为什么出现问题?</li>
<li>是否是多线程环境，是否有共享数据，是否有多条语句操作共享数据</li>
<li>7.4.2 如何解决多线程安全问题呢?</li>
<li>基本思想：让程序没有安全问题的环境。怎么实现呢?把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-5-同步代码块的方式解决线程安全问题"><a href="#7-5-同步代码块的方式解决线程安全问题" class="headerlink" title="7.5 同步代码块的方式解决线程安全问题"></a>7.5 同步代码块的方式解决线程安全问题</h4><ul>
<li><strong>7.5.1 同步代码块的格式</strong></li>
<li><p>同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">			需要同步的代码;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>7.5.2 通过线程安全的方式处理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">      AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">          executorService.execute(() -&gt; System.out.println(String.format(<span class="string">"窗口%s卖票中%s."</span>, Thread.currentThread().getName(), atomicInteger</span><br><span class="line">              .getAndIncrement())));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>7.5.2 同步代码块优势和劣势</strong></p>
</li>
<li>同步的好处:同步的出现解决了多线程的安全问题。</li>
<li>同步的弊端:当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</li>
<li>能通过一些原子性的操作来代替同步代码块，提升应用效率。同步代码块可以理解是一种乐观锁，而AtomicInteger则是通过CAS来实现的乐观锁。</li>
</ul>
<h4 id="8-关于思考问题解答"><a href="#8-关于思考问题解答" class="headerlink" title="8.关于思考问题解答"></a>8.关于思考问题解答</h4><ul>
<li><strong>a.wait()和sleep()的区别</strong><ul>
<li>sleep来自Thread类，和wait来自Object类 </li>
<li>调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁 </li>
<li>sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU </li>
<li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒</li>
</ul>
</li>
<li><strong>CAS原理</strong><ul>
<li>CAS指令在Intel CPU上称为CMPXCHG指令，它的作用是将指定内存地址的内容与所给的某个值相比，如果相等，则将其内容替换为指令中提供的新值，如果不相等，则更新失败。这一比较并交换的操作是原子的，不可以被中断。初一看，CAS也包含了读取、比较 (这也是种操作)和写入这三个操作，和之前的i++并没有太大区别，是的，的确在操作上没有区别，但CAS是通过硬件命令保证了原子性，而i++没有，且硬件级别的原子性比i++这样高级语言的软件级别的运行速度要快地多。虽然CAS也包含了多个操作，但其的运算是固定的(就是个比较)，这样的锁定性能开销很小。</li>
<li>从内存领域来说这是乐观锁，因为它在对共享变量更新之前会先比较当前值是否与更新前的值一致，如果是，则更新，如果不是，则无限循环执行(称为自旋)，直到当前值与更新前的值一致为止，才执行更新。简单的来说，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。这是一种乐观锁的思路，它相信在它修改之前，没有其它线程去修改它；而Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低。</li>
</ul>
</li>
<li><strong>CAS的缺点</strong><ul>
<li>虽然使用CAS可以实现非阻塞式的原子性操作，但是会产生ABA的问题。即在更新前的值是A，但是在操作过程中被其他线程更新成了B，然后又更新成了A。这时，当前线程是认为可以执行的，其实是发生了不一致的情况。所以如果这种不一致对程序有影响的话，应该使用AtomicStampedReference来做对比，它的原理是：除了对更新前的原值进行比较，也需要用更新前的 stamp标志位来进行比较。</li>
</ul>
</li>
</ul>
</div><div class="tags"><a href="/tags/多线程/">多线程</a></div><div class="post-nav"><a class="pre" href="/2018/11/21/java/thread/02-threadDeep/">多线程深入理解</a><a class="next" href="/2018/11/20/java/dataStructure/07.ConcurrentHashMap/">ConcurrentHashMap</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://fly.popc.top"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/鲁迅/" style="font-size: 15px;">鲁迅</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/io/" style="font-size: 15px;">io</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/03.TCP&UDP/">TCP和UDP详细介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/02.networkProgram2/">网络编程基础知识02</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/01.networkProgram/">网络编程基础知识01</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/07-threadDeadLock/">线程死锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/06-closeThread/">Thread关闭方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/05-synchronizeAndReentrantLock/">synchronize与ReentrantLock</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/04-synchronize/">synchronize深入理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/03-threadBackage/">多线程深入理解2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/02-threadDeep/">多线程深入理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/01-threadBase/">多线程基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">飞翔的企鹅.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>