<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这里是介绍"><title>03.Hash和HashCode深入理解 | 飞翔的企鹅</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">03.Hash和HashCode深入理解</h1><a id="logo" href="/.">飞翔的企鹅</a><p class="description">欢迎访问</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">03.Hash和HashCode深入理解</h1><div class="post-meta">Nov 20, 2018</div><div class="post-content"><h4 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h4><ul>
<li>1.Hash的作用介绍<ul>
<li>1.1 Hash的定义</li>
<li>1.2 Hash函数特性</li>
<li>1.3 Hash的使用场景</li>
</ul>
</li>
<li>2.如何判断两个对象相等<ul>
<li>2.1 判断两个字符串</li>
<li>2.2 判断两个int数值</li>
<li>2.3 其他基本类型</li>
</ul>
</li>
<li>3.HashCode深入分析<ul>
<li>3.0 HashCode是什么</li>
<li>3.1 为什么要重写HashCode</li>
<li>3.2 HashCode源代码分析</li>
<li>3.3 HashCode带来的疑问</li>
<li>3.4 HashCode的作用</li>
<li>3.5 HashMap中的HashCode</li>
<li>3.6 可直接用hashcode判断两个对象是否相等</li>
</ul>
</li>
<li>4.Hash表是什么<ul>
<li>4.1 Hash表定义</li>
<li>4.2 Hash表简单介绍</li>
</ul>
</li>
<li>5.Hash中的算法应用<ul>
<li>5.1 基础算法</li>
<li>5.2 经典算法[摘自网络]</li>
<li>5.3 Hash碰撞[摘自网络]</li>
</ul>
</li>
<li>6.Hash在Java中的应用场景<ul>
<li>6.1 equals与hashCode有两个注意点</li>
<li>6.2 以HashSet为例说明hashCode()的作用</li>
<li>6.3 以HashMap为例说明Hash的作用</li>
<li>6.4 </li>
</ul>
</li>
<li>7.版本更新情况</li>
<li>8.其他介绍</li>
</ul>
<h3 id="1-Hash的作用介绍"><a href="#1-Hash的作用介绍" class="headerlink" title="1.Hash的作用介绍"></a>1.Hash的作用介绍</h3><h4 id="1-1-Hash的定义"><a href="#1-1-Hash的定义" class="headerlink" title="1.1 Hash的定义"></a>1.1 Hash的定义</h4><ul>
<li>散列（哈希）函数<ul>
<li>把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值，是一种压缩映射。</li>
<li>或者说一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。</li>
</ul>
</li>
</ul>
<h4 id="1-2-Hash函数特性"><a href="#1-2-Hash函数特性" class="headerlink" title="1.2 Hash函数特性"></a>1.2 Hash函数特性</h4><ul>
<li>h(k1)≠h(k2)则k1≠k2，即散列值不相同，则输入值即预映射不同<ul>
<li>如果k1≠k2，h(k1)=h(k2) 则发生碰撞；</li>
<li>如果h(k1)=h(k2)，k1不一定等于k2；</li>
</ul>
</li>
</ul>
<h4 id="1-3-Hash的使用场景"><a href="#1-3-Hash的使用场景" class="headerlink" title="1.3 Hash的使用场景"></a>1.3 Hash的使用场景</h4><ul>
<li>比如说我们下载一个文件，文件的下载过程中会经过很多网络服务器、路由器的中转，如何保证这个文件就是我们所需要的呢？我们不可能去一一检测这个文件的每个字节，也不能简单地利用文件名、文件大小这些极容易伪装的信息，这时候，就需要一种指纹一样的标志来检查文件的可靠性，这种指纹就是我们现在所用的Hash算法(也叫散列算法)。</li>
<li>散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</li>
<li>这种标志有何意义呢？之前文件下载过程就是一个很好的例子，事实上，现在大部分的网络部署和版本控制工具都在使用散列算法来保证文件可靠性。</li>
</ul>
<h3 id="2-如何判断两个对象相等"><a href="#2-如何判断两个对象相等" class="headerlink" title="2.如何判断两个对象相等"></a>2.如何判断两个对象相等</h3><h4 id="2-1-判断两个字符串"><a href="#2-1-判断两个字符串" class="headerlink" title="2.1 判断两个字符串"></a>2.1 判断两个字符串</h4><ul>
<li><p>使用equals方法判断两个字符串是否相等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"yc1"</span>;</span><br><span class="line">String b = <span class="string">"yc2"</span>;</span><br><span class="line"><span class="keyword">boolean</span> isEqual = a.equals(b);</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然Object的子类可以通过重写equals的方法，实现子类自身的对象是否相等的逻辑；String是Object的子类，查看下它的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Object类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接比较的是地址</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在String类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接比较的是地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//盘旋是否是字符串String类型</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String) anObject;</span><br><span class="line">        <span class="keyword">int</span> n = count;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.count) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//循环判断每个字符是否相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charAt(i) != anotherString.charAt(i))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-判断两个int数值"><a href="#2-2-判断两个int数值" class="headerlink" title="2.2 判断两个int数值"></a>2.2 判断两个int数值</h4><ul>
<li>Integer类的equals方法又是如何实现的呢？<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer a = Integer.valueOf(<span class="string">"1"</span>);</span><br><span class="line">Integer b = Integer.valueOf(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">boolean</span> ab = a.equals(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先判断是否是Integer类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="comment">//转为int值后进行比较</span></span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-3-其他基本类型"><a href="#2-3-其他基本类型" class="headerlink" title="2.3 其他基本类型"></a>2.3 其他基本类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//short类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Short.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">short</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Byte类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Byte.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Long类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//long类型作为索引范围太大，需要转为int类型。这里简单的获取低32位容易导致散列不均，因为高位部分没有被利用。所以这里采用逻辑右移32位，让高32位和低32位进行XOR操作，导致高位低位都能被利用到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Boolean类型</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Boolean.hashCode(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//采用两个质数作为true或false的索引。这两个质数足够大，用来作为索引时，出现碰撞的可能性低。</span></span><br></pre></td></tr></table></figure>
<h3 id="3-HashCode深入分析"><a href="#3-HashCode深入分析" class="headerlink" title="3.HashCode深入分析"></a>3.HashCode深入分析</h3><h4 id="3-0-HashCode是什么"><a href="#3-0-HashCode是什么" class="headerlink" title="3.0 HashCode是什么"></a>3.0 HashCode是什么</h4><ul>
<li>HashCode是Object的一个方法，hashCode方法返回一个hash code值，且这个方法是为了更好的支持hash表，比如String，Set，HashTable、HashMap等;</li>
</ul>
<h4 id="3-1-为什么要重写HashCode"><a href="#3-1-为什么要重写HashCode" class="headerlink" title="3.1 为什么要重写HashCode"></a>3.1 为什么要重写HashCode</h4><ul>
<li>如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次equal去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上</li>
</ul>
<h4 id="3-2-HashCode源代码分析"><a href="#3-2-HashCode源代码分析" class="headerlink" title="3.2 HashCode源代码分析"></a>3.2 HashCode源代码分析</h4><ul>
<li><p>在Object中的HashCode源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lockWord = shadow$_monitor_;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lockWordStateMask = <span class="number">0xC0000000</span>; <span class="comment">// Top 2 bits.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lockWordStateHash = <span class="number">0x80000000</span>; <span class="comment">// Top 2 bits are value 2 (kStateHash).</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lockWordHashMask = <span class="number">0x0FFFFFFF</span>; <span class="comment">// Low 28 bits.</span></span><br><span class="line">    <span class="keyword">if</span> ((lockWord &amp; lockWordStateMask) == lockWordStateHash) &#123;</span><br><span class="line">        <span class="keyword">return</span> lockWord &amp; lockWordHashMask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回的是对象引用地址</span></span><br><span class="line">    <span class="keyword">return</span> System.identityHashCode(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在String中的HashCode源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Integer中的HashCode源代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-3-HashCode带来的疑问"><a href="#3-3-HashCode带来的疑问" class="headerlink" title="3.3 HashCode带来的疑问"></a>3.3 HashCode带来的疑问</h4><ul>
<li>为何重写equals建议同时重写hashCode？</li>
<li>hashCode是什么？</li>
<li>hashCode作用？</li>
<li>hash code（hash值）是什么？</li>
<li>hash table（hash表）是什么？</li>
<li>hashCode方法对hash表有益处？</li>
<li>hashCode方法对不是hash有益处吗?</li>
</ul>
<h4 id="3-4-HashCode的作用"><a href="#3-4-HashCode的作用" class="headerlink" title="3.4 HashCode的作用"></a>3.4 HashCode的作用</h4><ul>
<li>减少查找次数，提高程序效率<ul>
<li>例如查找是否存在重复值<ul>
<li>h(k1)≠h(k2)则k1≠k2</li>
<li>首先查看h(k2)输出值（内存地址），查看该内存地址是否存在值；</li>
<li>如果无，则表示该值不存在重复值；</li>
<li>如果有，则进行值比较，相同则表示该值已经存在散列列表中，如果不相同则再进行一个一个值比较；而无需一开始就一个一个值的比较，减少了查找次数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-HashMap中的HashCode"><a href="#3-5-HashMap中的HashCode" class="headerlink" title="3.5 HashMap中的HashCode"></a>3.5 HashMap中的HashCode</h4><ul>
<li>在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</li>
<li>为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？<strong>（注意：集合中不允许重复的元素存在）</strong><ul>
<li>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。</li>
<li>此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。下面这段代码是java.util.HashMap的中put方法的具体实现：</li>
</ul>
</li>
<li>put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-6-可直接用hashcode判断两个对象是否相等"><a href="#3-6-可直接用hashcode判断两个对象是否相等" class="headerlink" title="3.6 可直接用hashcode判断两个对象是否相等"></a>3.6 可直接用hashcode判断两个对象是否相等</h4><ul>
<li>肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。</li>
<li>也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；<ul>
<li>如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；</li>
<li>如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；</li>
<li>如果两个对象的hashcode值相等，则equals方法得到的结果未知。</li>
</ul>
</li>
</ul>
<h3 id="4-Hash表是什么"><a href="#4-Hash表是什么" class="headerlink" title="4.Hash表是什么"></a>4.Hash表是什么</h3><h4 id="4-1-Hash表定义"><a href="#4-1-Hash表定义" class="headerlink" title="4.1 Hash表定义"></a>4.1 Hash表定义</h4><ul>
<li>根据关键码值（KEY-VALUE）而直接进行访问的数据结构；它通过把关键码值（KEY-VALUE）映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</li>
</ul>
<h4 id="4-2-Hash表简单介绍"><a href="#4-2-Hash表简单介绍" class="headerlink" title="4.2 Hash表简单介绍"></a>4.2 Hash表简单介绍</h4><ul>
<li>将k作为输入值，h(k)输出值作为内存地址，该内存地址用来存放value，然后可以通过k获取到value存放的地址，从而获取value信息。</li>
</ul>
<h3 id="5-Hash中的算法应用"><a href="#5-Hash中的算法应用" class="headerlink" title="5.Hash中的算法应用"></a>5.Hash中的算法应用</h3><h4 id="5-1-基础算法"><a href="#5-1-基础算法" class="headerlink" title="5.1 基础算法"></a>5.1 基础算法</h4><ul>
<li>比如，Java中的String.hashCode使用乘法和加法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//乘法与加法</span></span><br><span class="line">            h = <span class="number">31</span> * h + charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-经典算法-摘自网络"><a href="#5-2-经典算法-摘自网络" class="headerlink" title="5.2 经典算法[摘自网络]"></a>5.2 经典算法[摘自网络]</h4><ul>
<li>MD4，MD5，SHA-1或SHA-2等其他</li>
</ul>
<h4 id="5-3-Hash碰撞-摘自网络"><a href="#5-3-Hash碰撞-摘自网络" class="headerlink" title="5.3 Hash碰撞[摘自网络]"></a>5.3 Hash碰撞[摘自网络]</h4><ul>
<li>hash是存在碰撞的，如果k1≠k2，h(k1)=h(k2) 则发生碰撞；</li>
</ul>
<h3 id="6-Hash在Java中的应用场景"><a href="#6-Hash在Java中的应用场景" class="headerlink" title="6.Hash在Java中的应用场景"></a>6.Hash在Java中的应用场景</h3><h4 id="6-1-equals与hashCode有两个注意点"><a href="#6-1-equals与hashCode有两个注意点" class="headerlink" title="6.1 equals与hashCode有两个注意点"></a>6.1 equals与hashCode有两个注意点</h4><ul>
<li>equals相同，则hashCode相同；而hashCode相同，equals不一定相同<ul>
<li>如果equals相同，hashCode不相同，有可能会造成上述重复值等情况，这种情况是不允许的；</li>
<li>而hasCode相同，但是equals不一定相同，有可能是因为发生了碰撞而碰撞是有可能性发生的</li>
</ul>
</li>
</ul>
<h4 id="6-2-以HashSet为例说明hashCode-的作用"><a href="#6-2-以HashSet为例说明hashCode-的作用" class="headerlink" title="6.2 以HashSet为例说明hashCode()的作用"></a>6.2 以HashSet为例说明hashCode()的作用</h4><ul>
<li>假设，HashSet中已经有1000个元素。当插入第1001个元素时，需要怎么处理？<ul>
<li>因为HashSet是Set集合，它不允许有重复元素。“将第1001个元素逐个的和前面1000个元素进行比较”？</li>
<li>显然，这个效率是相等低下的。散列表很好的解决了这个问题，它根据元素的散列码计算出元素在散列表中的位置，然后将元素插入该位置即可。对于相同的元素，自然是只保存了一个。</li>
<li>由此可知，若两个元素相等，它们的散列码一定相等；但反过来确不一定。在散列表中，<ul>
<li>1、如果两个对象相等，那么它们的hashCode()值一定要相同；</li>
<li>2、如果两个对象hashCode()相等，它们并不一定相等。</li>
<li>注意：这是在散列表中的情况。在非散列表中一定如此！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-3-以HashMap为例说明Hash的作用"><a href="#6-3-以HashMap为例说明Hash的作用" class="headerlink" title="6.3 以HashMap为例说明Hash的作用"></a>6.3 以HashMap为例说明Hash的作用</h4><ul>
<li>在HashMap中有许多地方用到了hash算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//put方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面这几个方法都用到了这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">//计算hashCode，并无符号移动到低位</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">举个例子: h = <span class="number">363771819</span>^(<span class="number">363771819</span> &gt;&gt;&gt; <span class="number">16</span>)</span><br><span class="line"><span class="number">0001</span> <span class="number">0101</span> <span class="number">1010</span> <span class="number">1110</span> <span class="number">1011</span> <span class="number">0111</span> <span class="number">1010</span> <span class="number">1011</span>(<span class="number">363771819</span>)</span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">0101</span> <span class="number">1010</span> <span class="number">1110</span>(<span class="number">5550</span>) XOR</span><br><span class="line">--------------------------------------- =</span><br><span class="line"><span class="number">0001</span> <span class="number">0101</span> <span class="number">1010</span> <span class="number">1110</span> <span class="number">1010</span> <span class="number">0010</span> <span class="number">0000</span> <span class="number">0101</span>(<span class="number">363766277</span>)</span><br><span class="line">这样做可以实现了高地位更加均匀地混到一起</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul>
<li>Java Hash 存储机制：<a href="http://blog.chinaunix.net/uid-26981819-id-4462638.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-26981819-id-4462638.html</a></li>
<li>数据结构之哈希表：<a href="https://www.cnblogs.com/s-b-b/p/6208565.html" target="_blank" rel="noopener">https://www.cnblogs.com/s-b-b/p/6208565.html</a></li>
<li>Java hashCode() 和 equals()的若干问题解答：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3324958.html</a></li>
<li>Hash算法总结：<a href="https://blog.csdn.net/asdzheng/article/details/70226007" target="_blank" rel="noopener">https://blog.csdn.net/asdzheng/article/details/70226007</a></li>
<li>浅谈Java中的hashcode方法：<a href="http://www.cnblogs.com/dolphin0520/p/3681042.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3681042.html</a></li>
</ul>
</div><div class="tags"><a href="/tags/java/">java</a></div><div class="post-nav"><a class="pre" href="/2018/11/20/java/dataStructure/01.baseDataStructure/">常见的数据结构</a><a class="next" href="/2018/11/20/java/base/10-memoryAllocationAndLeakage/">java内存分配和泄露</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://fly.popc.top"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/鲁迅/" style="font-size: 15px;">鲁迅</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/io/" style="font-size: 15px;">io</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/22/试试/">试试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/03.TCP&UDP/">TCP和UDP详细介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/02.networkProgram2/">网络编程基础知识02</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/01.networkProgram/">网络编程基础知识01</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/07-threadDeadLock/">线程死锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/06-closeThread/">Thread关闭方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/05-synchronizeAndReentrantLock/">synchronize与ReentrantLock</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/04-synchronize/">synchronize深入理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/03-threadBackage/">多线程深入理解2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/02-threadDeep/">多线程深入理解</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">飞翔的企鹅.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>