<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这里是介绍"><title>常见的数据结构 | 飞翔的企鹅</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">常见的数据结构</h1><a id="logo" href="/.">飞翔的企鹅</a><p class="description">欢迎访问</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">常见的数据结构</h1><div class="post-meta">Nov 20, 2018</div><div class="post-content"><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul>
<li>1.常用数据有哪些</li>
<li>2.数据的说明</li>
<li>3.集合数据结构介绍</li>
<li>4.集合{List，Set，Map}的特点</li>
<li>5.Queue队列</li>
</ul>
<h4 id="1-常用数据有哪些？"><a href="#1-常用数据有哪些？" class="headerlink" title="1.常用数据有哪些？"></a>1.常用数据有哪些？</h4><ul>
<li><strong>1.1 如下图所示：</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-84cb744b434c0bc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/4432347-95c1a4cac03f1510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<ul>
<li><strong>1.2 常见的集合数据</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-99e078e9f90f1366.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li>
</ul>
<h4 id="2-数据的说明"><a href="#2-数据的说明" class="headerlink" title="2.数据的说明"></a>2.数据的说明</h4><ul>
<li><strong>2.1 数组</strong></li>
<li><img src="https://upload-images.jianshu.io/upload_images/4432347-44f75cb827c7ce06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><ul>
<li>无序数组<ul>
<li>优点：查询快,如果知道索引可以快速地存取</li>
<li>缺点：删除慢,大小固定</li>
</ul>
</li>
<li>有序数组<ul>
<li>优点：比无序数组查找快</li>
<li>缺点：删除和插入慢，大小固定</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.2 栈</strong><ul>
<li>优点：提供后进先出的存取方式</li>
<li>缺点：存取其他项很慢</li>
<li>比如，Android中管理activity进出就是使用栈</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.3 队列</strong><ul>
<li>优点：提供先进先出的存取方式</li>
<li>缺点：存取其他项都很慢</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.4 链表</strong><ul>
<li>优点：插入快，删除快</li>
<li>缺点：查找慢(一个个节点查)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.5 二叉树</strong><ul>
<li>优点：查找，插入，删除都快（平衡二叉树）</li>
<li>缺点：删除算法复杂</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.6 红-黑树</strong><ul>
<li>优点：查找，插入，删除都快，树总是平衡的(局部调整)</li>
<li>缺点：算法复杂</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.7 哈希表</strong><ul>
<li>优点：如果关键字已知则存取速度极快，插入快</li>
<li>缺点：删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.8 堆</strong><ul>
<li>优点：插入，删除快，对最大数据的项存取很快</li>
<li>缺点：对其他数据项存取很慢</li>
</ul>
</li>
</ul>
<ul>
<li><strong>2.9 图</strong><ul>
<li>优点：对现实世界建模</li>
<li>缺点：有些算法慢且复杂</li>
</ul>
</li>
</ul>
<h4 id="3-集合数据结构介绍"><a href="#3-集合数据结构介绍" class="headerlink" title="3.集合数据结构介绍"></a>3.集合数据结构介绍</h4><ul>
<li><strong>3.1 Set集合【一般使用的有TreeSet和HashSet】</strong></li>
<li>3.1.1 TreeSet<ul>
<li>TreeSet是根据二叉树实现的，也就是TreeMap, 放入数据不能重复且不能为null,可以重写compareTo()方法来确定元素大小，从而进行升序排序。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class DataType &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Set&lt;Integer&gt; treeSet = new TreeSet&lt;&gt;(new MyComparator());</span><br><span class="line">        treeSet.add(1);</span><br><span class="line">        treeSet.add(3);</span><br><span class="line">        treeSet.add(2);</span><br><span class="line">        for(Integer i : treeSet)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyComparator implements Comparator&lt;Integer&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">            if(o1 &lt; o2 )&#123;</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            if(o1 == o2 )&#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if(o1 &gt; o2 )&#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1.2 HashSet<ul>
<li>HashSet是根据hashCode来决定存储位置的，是通过HashMap实现的，所以对象必须实现hashCode()方法，存储的数据无序不能重复，可以存储null,但是只能存一个。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class DataType &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Set&lt;String&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        set.add(&quot;1&quot;);</span><br><span class="line">        set.add(&quot;2&quot;);</span><br><span class="line">        set.add(null);</span><br><span class="line">        set.add(&quot;1&quot;);</span><br><span class="line">        for(String s : set)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">null</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.2 List集合【List比较常用的有ArrayList和LinkedList，还有一个比较类似的Vector】</strong></li>
<li>3.2.1 ArrayList<ul>
<li>是使用动态数组来实现的，对于数据的随机get和set或是少量数据的插入或删除，效率会比较高。ArrayList是线程不安全的，在不考虑线程安全的情况下速度也比较快的。ArrayList插入数据可以重复，也是有序的，按照插入的顺序来排序。</li>
<li>根据序号读取数据只需直接获取数组对应脚表的数据</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ListTest &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">        arrayList.add(&quot;2&quot;);</span><br><span class="line">        arrayList.remove(&quot;1&quot;);</span><br><span class="line">        for(String s : arrayList)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">内部使用动态数组来实现</span><br><span class="line"></span><br><span class="line">/**Shared empty array instance used for empty instances.*/</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">         this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.2.2 LinkedList</strong><ul>
<li>内部是使用链表的形式来实现的,在插入大量数据的时候效率比较快。</li>
<li>LinkedList根据序号获取数据，是二分进行遍历，如果序号小于总长度的一半，就从链表头部开始往后遍历，直到找到对应的序号。如果序号大于总长度的一半，就从链表尾部往前进行遍历，直到找到对应的序号。拿到数据。</li>
<li>链表实现的代码</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">往容器最后面添加元素的代码是:</span><br><span class="line"> /**</span><br><span class="line">     * Pointer to first node.</span><br><span class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">     *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Pointer to last node.</span><br><span class="line">     * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="line">     *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">往容器最前面添加元素的代码</span><br><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    if (f == null)</span><br><span class="line">        last = newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">根据序号获取数据：</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    //判断index序号是否是合法的</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;//判断序号在总长度一半之前还是之后</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>3.2.3 Vector</strong><ul>
<li>Vector的使用方法和内部实现基本和ArrayList相同，只不过它在add(), remove(), get()等方法中都加了同步。所以它是线程安全的。但是使用效率上就不如ArrayList了。</li>
</ul>
</li>
</ul>
<h4 id="4-Map集合【HashMap，TreeMap，HashTable】"><a href="#4-Map集合【HashMap，TreeMap，HashTable】" class="headerlink" title="4.Map集合【HashMap，TreeMap，HashTable】"></a>4.Map集合【HashMap，TreeMap，HashTable】</h4><ul>
<li><strong>4.1 HashMap</strong><ul>
<li>HashMap是基于散列链表来实现的，简单的来说，根据key算出一个hash值，确定一个存放index,但是hash值有可能会冲突重复，所以如果冲突的hash值就需要以链表的形式在同一个index存放了。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">hashMap.put(&quot;1&quot;, &quot;a&quot;);//存储</span><br><span class="line">hashMap.put(&quot;2&quot;, &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">hashMap.remove(&quot;1&quot;);//根据key来删除</span><br><span class="line">hashMap.get(&quot;2&quot;);//根据key获取</span><br><span class="line"></span><br><span class="line">//map的遍历,有很多方法遍历,这里只列举一种。</span><br><span class="line">for(Map.Entry&lt;String, String&gt; entry : hashMap.entrySet())&#123;</span><br><span class="line">    entry.getKey();//获取key</span><br><span class="line">    entry.getValue();//获取value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>4.2 TreeMap</strong><ul>
<li>TreeMap的使用大致跟HashMap类似，但是内部实现是根据红黑树来实现的。红黑树是一种平衡有序的二叉树，TreeMap的插入删除查询都是依据红黑树的规则来进行的。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>4.3 HashTable</strong><ul>
<li>HashMap和TreeMap都是线程不安全的，多线程操作的时候可能会造成数据错误。Hashtable是线程安全的。其他内部实现，与HashMap都是一样的。</li>
</ul>
</li>
</ul>
<h3 id="5-Queue队列"><a href="#5-Queue队列" class="headerlink" title="5.Queue队列"></a>5.Queue队列</h3><h4 id="5-1-什么是队列"><a href="#5-1-什么是队列" class="headerlink" title="5.1 什么是队列"></a>5.1 什么是队列</h4><ul>
<li>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</li>
</ul>
<h4 id="5-2-队列的种类"><a href="#5-2-队列的种类" class="headerlink" title="5.2 队列的种类"></a>5.2 队列的种类</h4><ul>
<li><strong>单队列</strong>（单队列就是常见的队列, 每次添加元素时，都是添加到队尾，存在“假溢出”的问题也就是明明有位置却不能添加的情况）</li>
<li><strong>循环队列</strong>（避免了“假溢出”的问题）</li>
</ul>
<h4 id="5-3-Java-集合框架中的队列-Queue"><a href="#5-3-Java-集合框架中的队列-Queue" class="headerlink" title="5.3 Java 集合框架中的队列 Queue"></a>5.3 Java 集合框架中的队列 Queue</h4><ul>
<li>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。</li>
</ul>
<h3 id="关于其他内容介绍"><a href="#关于其他内容介绍" class="headerlink" title="关于其他内容介绍"></a>关于其他内容介绍</h3><h4 id="01-关于博客汇总链接"><a href="#01-关于博客汇总链接" class="headerlink" title="01.关于博客汇总链接"></a>01.关于博客汇总链接</h4><ul>
<li>1.<a href="https://www.jianshu.com/p/614cb839182c" target="_blank" rel="noopener">技术博客汇总</a></li>
<li>2.<a href="https://blog.csdn.net/m0_37700275/article/details/80863574" target="_blank" rel="noopener">开源项目汇总</a></li>
<li>3.<a href="https://blog.csdn.net/m0_37700275/article/details/79832978" target="_blank" rel="noopener">生活博客汇总</a></li>
<li>4.<a href="https://www.jianshu.com/p/f665de16d1eb" target="_blank" rel="noopener">喜马拉雅音频汇总</a></li>
<li>5.<a href="https://www.jianshu.com/p/53017c3fc75d" target="_blank" rel="noopener">其他汇总</a></li>
</ul>
<h4 id="02-关于我的博客"><a href="#02-关于我的博客" class="headerlink" title="02.关于我的博客"></a>02.关于我的博客</h4><ul>
<li>我的个人站点：<a href="http://www.yczbj.org，www.ycbjie.cn" target="_blank" rel="noopener">www.yczbj.org，www.ycbjie.cn</a></li>
<li>github：<a href="https://github.com/yangchong211" target="_blank" rel="noopener">https://github.com/yangchong211</a></li>
<li>知乎：<a href="https://www.zhihu.com/people/yang-chong-69-24/pins/posts" target="_blank" rel="noopener">https://www.zhihu.com/people/yang-chong-69-24/pins/posts</a></li>
<li>简书：<a href="http://www.jianshu.com/u/b7b2c6ed9284" target="_blank" rel="noopener">http://www.jianshu.com/u/b7b2c6ed9284</a></li>
<li>csdn：<a href="http://my.csdn.net/m0_37700275" target="_blank" rel="noopener">http://my.csdn.net/m0_37700275</a></li>
<li>喜马拉雅听书：<a href="http://www.ximalaya.com/zhubo/71989305/" target="_blank" rel="noopener">http://www.ximalaya.com/zhubo/71989305/</a></li>
<li>开源中国：<a href="https://my.oschina.net/zbj1618/blog" target="_blank" rel="noopener">https://my.oschina.net/zbj1618/blog</a></li>
<li>泡在网上的日子：<a href="http://www.jcodecraeer.com/member/content_list.php?channelid=1" target="_blank" rel="noopener">http://www.jcodecraeer.com/member/content_list.php?channelid=1</a></li>
<li>邮箱：<a href="mailto:yangchong211@163.com" target="_blank" rel="noopener">yangchong211@163.com</a></li>
<li>阿里云博客：<a href="https://yq.aliyun.com/users/article?spm=5176.100-" target="_blank" rel="noopener">https://yq.aliyun.com/users/article?spm=5176.100-</a> 239.headeruserinfo.3.dT4bcV</li>
<li>segmentfault头条：<a href="https://segmentfault.com/u/xiangjianyu/articles" target="_blank" rel="noopener">https://segmentfault.com/u/xiangjianyu/articles</a></li>
</ul>
</div><div class="tags"><a href="/tags/数据结构/">数据结构</a></div><div class="post-nav"><a class="pre" href="/2018/11/20/java/dataStructure/02.baseDataStructure2/">java常用数据结构深度解析</a><a class="next" href="/2018/11/20/java/base/09-HashAndHashCode/">03.Hash和HashCode深入理解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="https://fly.popc.top"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/鲁迅/" style="font-size: 15px;">鲁迅</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/网络编程/" style="font-size: 15px;">网络编程</a> <a href="/tags/反射/" style="font-size: 15px;">反射</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/io/" style="font-size: 15px;">io</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/03.TCP&UDP/">TCP和UDP详细介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/02.networkProgram2/">网络编程基础知识02</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/network/01.networkProgram/">网络编程基础知识01</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/07-threadDeadLock/">线程死锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/06-closeThread/">Thread关闭方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/05-synchronizeAndReentrantLock/">synchronize与ReentrantLock</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/04-synchronize/">synchronize深入理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/03-threadBackage/">多线程深入理解2</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/02-threadDeep/">多线程深入理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/21/java/thread/01-threadBase/">多线程基础</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">飞翔的企鹅.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>